//=============================================================================
//
// 	Token.h   
//
// 	Author:	 James Boer
//
//	Copyright (C) 2001 James R. Boer  All Rights Reserved.
//	
//=============================================================================
#pragma once

#ifndef __TOKEN_H
#define __TOKEN_H

#define TOKEN_DEBUGGING_INFO

#pragma warning(disable:4786)

// Required for GUID definition
#include <windows.h>
#include <vector>
#include <list>
#include <assert.h>


// This is the basic data object generated by the Parser class
class Token 
{
public:
	enum TOKEN_TYPE
	{
		UNKNOWN_TOKEN = 0,
		KEYWORD,
		OPERATOR,
		VARIABLE,
		STRING,
		INTEGER,
		REAL,
		BOOLEAN,
		T_GUID
	};


	Token()						{  Clear();  }
	Token(const Token& tok);
	virtual ~Token()			{  Destroy();  }
	void Clear();

	void operator = ( const Token& tok);

	inline bool CreateKeyword(const char* pszKeyword)
	{
		m_Type = KEYWORD;
		m_pszKeyword = new char[strlen(pszKeyword) + 1];
		if(!m_pszKeyword)
			return false;
		strcpy(m_pszKeyword, pszKeyword);
		return true;
	}

	inline bool CreateOperator(const char* pszOperator)
	{
		m_Type = OPERATOR;
		m_pszOperator = new char[strlen(pszOperator) + 1];
		if(!m_pszOperator)
			return false;
		strcpy(m_pszOperator, pszOperator);
		return true;
	}

	inline bool CreateVariable(const char* pszVariable)
	{
		m_Type = VARIABLE;
		m_pszVariable = new char[strlen(pszVariable) + 1];
		if(!m_pszVariable)
			return false;
		strcpy(m_pszVariable, pszVariable);
		return true;
	}

	inline bool CreateString(const char* pszString)
	{
		m_Type = STRING;
		m_pszString = new char[strlen(pszString) + 1];
		if(!m_pszString)
			return false;
		strcpy(m_pszString, pszString);
		return true;
	}

	inline bool CreateInteger(int iInteger)
	{
		m_Type = INTEGER;
		m_iInteger = iInteger;
		return true;
	}

	inline bool CreateReal(double dReal)
	{
		m_Type = REAL;
		m_dReal = dReal;
		return true;
	}

	inline bool CreateBoolean(bool bBoolean)
	{
		m_Type = BOOLEAN;
		m_bBoolean = bBoolean;
		return true;
	}

	inline bool CreateGuid(const GUID& guidGuid)
	{
		m_Type = T_GUID;
		m_pguidGuid = new GUID;
		if(!m_pguidGuid)
			return false;
		memcpy(m_pguidGuid, &guidGuid, sizeof(GUID));
		return true;
	}

	void Destroy();

	inline void SetVariable(const char* pszVariable)
	{
		assert(m_Type == VARIABLE);
		delete[] m_pszVariable;
		m_pszVariable = 0;
		CreateVariable(pszVariable);
	}

	inline void SetKeyword(const char* pszKeyword)
	{
		assert(m_Type == KEYWORD);
		delete[] m_pszKeyword;
		m_pszKeyword = 0;
		CreateKeyword(pszKeyword);
	}

	inline void SetString(const char* pszString)
	{
		assert(m_Type == STRING);
		delete[] m_pszString;
		m_pszString = 0;
		CreateString(pszString);
	}

	inline void SetOperator(const char* pszOperator)
	{
		assert(m_Type == OPERATOR);
		delete[] m_pszOperator;
		m_pszOperator = 0;
		CreateOperator(pszOperator);
	}

	inline void SetInteger(const int iInteger)
	{
		assert(m_Type == INTEGER);
		CreateInteger(iInteger);
	}

	inline void SetBoolean(const bool bBoolean)
	{
		assert(m_Type == BOOLEAN);
		CreateBoolean(bBoolean);
	}

	inline void SetReal(const double dReal)
	{
		assert(m_Type == REAL);
		CreateReal(dReal);
	}

	inline void SetGuid(const GUID& guidGuid)
	{
		assert(m_Type == T_GUID);
		delete m_pguidGuid;
		m_pguidGuid = 0;
		CreateGuid(guidGuid);
	}

	// querry the type of token
	inline bool IsUnknown()	const		{  return (m_Type == UNKNOWN_TOKEN) ? true : false;  }
	inline bool IsKeyword()	const		{  return (m_Type == KEYWORD) ? true : false;  }
	inline bool IsOperator() const		{  return (m_Type == OPERATOR) ? true : false;  }
	inline bool IsVariable() const		{  return (m_Type == VARIABLE) ? true : false;  }
	inline bool IsString() const		{  return (m_Type == STRING) ? true : false;  }
	inline bool IsInteger()	const		{  return (m_Type == INTEGER) ? true : false;  }
	inline bool IsReal() const			{  return (m_Type == REAL) ? true : false;  }
	inline bool IsBoolean()	const		{  return (m_Type == BOOLEAN) ? true : false;  }
	inline bool IsGuid() const			{  return (m_Type == T_GUID) ? true : false;  }
	inline TOKEN_TYPE GetType() const	{  return m_Type;  }

	// get the token content
	inline const char* GetKeyword() const	{  assert(m_Type == KEYWORD);  return (const char*)m_pszKeyword;  }
	inline const char* GetOperator() const	{  assert(m_Type == OPERATOR);  return (const char*)m_pszOperator;  }
	inline const char* GetVariable() const	{  assert(m_Type == VARIABLE);  return (const char*)m_pszVariable;  }
	inline const char* GetString() const	{  assert(m_Type == STRING);  return (const char*)m_pszString;  }
	inline int GetInteger() const			{  assert(m_Type == INTEGER);  return m_iInteger;  }
	inline double GetReal() const			{  assert(m_Type == REAL);  return m_dReal;  }
	inline bool GetBoolean() const			{  assert(m_Type == BOOLEAN);  return m_bBoolean;  }
	inline GUID& GetGuid() const			{  assert(m_Type == T_GUID);  return *m_pguidGuid;  }

	inline bool IsNewline() const			{  return (IsOperator() && (GetOperator()[0] == '\n')) ? true : false;  }

	const char* GetDescriptiveString() const;
	
#ifdef TOKEN_DEBUGGING_INFO
	inline void SetLineNumber(int iLineNo)	{  m_iLineNumber = iLineNo;  }
	inline int GetLineNumber() const		{  return m_iLineNumber;  }
	inline void SetFileIndex(int iIndex)	{  m_iFileIndex = iIndex;  }
	inline int GetFileIndex() const			{  return m_iFileIndex;  }
#endif // TOKEN_DEBUGGING_INFO


protected:

	// This tells us which type of data we're carrying
	TOKEN_TYPE m_Type;

	// The data is in one of these fields.  We're only going to be using
	// one type per token, so no reason to waste space.  So, we make
	// the data fields part of a union.
	union
	{
		char*			m_pszKeyword;
		char*			m_pszOperator;
		char*			m_pszVariable;
		char*			m_pszString;
		int				m_iInteger;
		double			m_dReal;
		bool			m_bBoolean;
		GUID*			m_pguidGuid;
	};

#ifdef TOKEN_DEBUGGING_INFO
	// Indicates the line number in which the token was found.
	// Note that although this is debugging information, it should
	// not only be contained in debug builds, since we may want to
	// "debug" release mode applications which still will be using
	// this parser.
	int m_iLineNumber;

	// References an index into a string table containing the source
	// file in which this token was found.
	int m_iFileIndex;
#endif // TOKEN_DEBUGGING_INFO

};

// stream operators
// this is to support a tokenized file representation of a parsed file
inline std::ostream& operator<<( std::ostream& os, Token& tok );
inline std::istream& operator>>( std::istream& is, Token& tok );


typedef std::vector<std::string> StringVector;
typedef std::vector<Token> TokenVector;
typedef std::vector<Token> TokenVector;

typedef std::list<Token>::iterator TokenListItor;

// TokenList is the standard list type for tokens.  It's a basic STL list
// of type token with some enhancements for storing and retrieving debugging info
class TokenList : public std::list<Token>
{
public:

	// Gets a descriptive string of the token including file name and line number
	std::string GetDescriptiveString(TokenListItor itr) const;
	// Gets a string of the file name from where the token was parsed
	//std::string GetFileName(TokenListItor itr) const;
	std::string GetFileName(int index) const;
	// Gets the line number of the token
	int GetLineNumber(TokenListItor itr) const;
	
	// Given a filename, find the index into the filelist vector.  If it doesn't
	// currently exist in the vector, push it onto the end and return the
	// new index value.
	int GetFileIndex(std::string sFileName);

	// Get the total number of file references in this token list
	int GetNumFileRefs() const;

	void clear();
	
private:
	StringVector m_aFileRef;
};



#endif // __TOKEN_H