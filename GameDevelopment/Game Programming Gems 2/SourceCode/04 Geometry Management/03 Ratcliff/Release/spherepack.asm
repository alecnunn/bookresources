	TITLE	C:\WINDOWS\Desktop\Gems2 CD\SourceCode\04 Geometry Management\03 Ratcliff\spherepack.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_00A@?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0FG@ILEN@?3Sun?3Sunday?3Mon?3Monday?3Tue?3Tuesd@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0IH@JLLA@?3Jan?3January?3Feb?3February?3Mar?3Ma@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05NAGO@false?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04NCCD@true?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_02ELCB@no?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03LGKI@yes?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_01FKHJ@C?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BP@KLJH@invalid?5vector?$DMbool?$DO?5subscript?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BF@MMAA@missing?5locale?5facet?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT _sqrtf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_Lockit@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1_Lockit@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1bad_exception@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Doraise@bad_exception@std@@MBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gbad_exception@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0bad_exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Doraise@bad_alloc@std@@MBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _wmemchr
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _wmemcmp
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _wmemcpy
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _wmemmove
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _wmemset
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?copy@?$char_traits@G@std@@SAPAGPAGPBGI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?to_char_type@?$char_traits@G@std@@SAGABG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?to_int_type@?$char_traits@G@std@@SAGABG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?eq_int_type@?$char_traits@G@std@@SA_NABG0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?eof@?$char_traits@G@std@@SAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?to_char_type@?$char_traits@D@std@@SADABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?to_int_type@?$char_traits@D@std@@SAHABD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?eof@?$char_traits@D@std@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Doraise@logic_error@std@@MBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1domain_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Doraise@domain_error@std@@MBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gdomain_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0domain_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1invalid_argument@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Doraise@invalid_argument@std@@MBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Ginvalid_argument@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0invalid_argument@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Doraise@length_error@std@@MBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1out_of_range@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Doraise@out_of_range@std@@MBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gout_of_range@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0out_of_range@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1runtime_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?what@runtime_error@std@@UBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Doraise@runtime_error@std@@MBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gruntime_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0runtime_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1overflow_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Doraise@overflow_error@std@@MBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Goverflow_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0overflow_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1underflow_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Doraise@underflow_error@std@@MBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gunderflow_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0underflow_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1range_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Doraise@range_error@std@@MBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Grange_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0range_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0bad_cast@std@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1bad_cast@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Doraise@bad_cast@std@@MBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gbad_cast@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0bad_cast@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0bad_typeid@std@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1bad_typeid@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Doraise@bad_typeid@std@@MBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gbad_typeid@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0bad_typeid@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G__non_rtti_object@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1__non_rtti_object@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_Timevec@std@@QAE@PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1_Timevec@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4_Timevec@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Bid@locale@std@@QAEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Incref@facet@locale@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Decref@facet@locale@std@@QAEPAV123@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1facet@locale@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0facet@locale@std@@IAE@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0locale@std@@QAE@W4_Uninitialized@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0locale@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1locale@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gfacet@locale@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Narrow@std@@YAHG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Widen@std@@YAGDPAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0codecvt_base@std@@QAE@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_always_noconv@codecvt_base@std@@MBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_max_length@codecvt_base@std@@MBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_encoding@codecvt_base@std@@MBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gcodecvt_base@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1codecvt_base@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$codecvt@GDH@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Init@?$codecvt@GDH@std@@IAEXABV_Locinfo@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_in@?$codecvt@GDH@std@@MBEHAAHPBD1AAPBDPAG3AAPAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_out@?$codecvt@GDH@std@@MBEHAAHPBG1AAPBGPAD3AAPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_length@?$codecvt@GDH@std@@MBEHAAHPBG1I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_always_noconv@?$codecvt@GDH@std@@MBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_max_length@?$codecvt@GDH@std@@MBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_encoding@?$codecvt@GDH@std@@MBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$codecvt@GDH@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ctype_base@std@@QAE@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gctype_base@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1ctype_base@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?is@?$ctype@D@std@@QBE_NFD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$ctype@D@std@@QAE@PBF_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$ctype@D@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Term@?$ctype@D@std@@KAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_tolower@?$ctype@D@std@@MBEDD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_toupper@?$ctype@D@std@@MBEDD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$ctype@D@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1failure@ios_base@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Doraise@failure@ios_base@std@@MBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?rdstate@ios_base@std@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setstate@ios_base@std@@QAEXH_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?good@ios_base@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?fail@ios_base@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?exceptions@ios_base@std@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?flags@ios_base@std@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setf@ios_base@std@@QAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setf@ios_base@std@@QAEHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?unsetf@ios_base@std@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?getloc@ios_base@std@@QBE?AVlocale@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gfailure@ios_base@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0failure@ios_base@std@@QAE@ABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gios_base@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0reference@?$vector@_NV?$allocator@I@std@@@std@@QAE@IPAI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4reference@?$vector@_NV?$allocator@I@std@@@std@@QAEAAV012@ABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4reference@?$vector@_NV?$allocator@I@std@@@std@@QAEAAV012@_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Breference@?$vector@_NV?$allocator@I@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@_NV?$allocator@I@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@_NV?$allocator@I@std@@@std@@QAE@IPBI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$vector@_NV?$allocator@I@std@@@std@@QBE?BVreference@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$vector@_NV?$allocator@I@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Yconst_iterator@?$vector@_NV?$allocator@I@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Zconst_iterator@?$vector@_NV?$allocator@I@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Hconst_iterator@?$vector@_NV?$allocator@I@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Gconst_iterator@?$vector@_NV?$allocator@I@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Gconst_iterator@?$vector@_NV?$allocator@I@std@@@std@@QBEHV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$vector@_NV?$allocator@I@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$vector@_NV?$allocator@I@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Mconst_iterator@?$vector@_NV?$allocator@I@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Dec@const_iterator@?$vector@_NV?$allocator@I@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$vector@_NV?$allocator@I@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$vector@_NV?$allocator@I@std@@@std@@QAE@IPAI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$vector@_NV?$allocator@I@std@@@std@@QBE?AVreference@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$vector@_NV?$allocator@I@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Fiterator@?$vector@_NV?$allocator@I@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Yiterator@?$vector@_NV?$allocator@I@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Ziterator@?$vector@_NV?$allocator@I@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Hiterator@?$vector@_NV?$allocator@I@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Giterator@?$vector@_NV?$allocator@I@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Giterator@?$vector@_NV?$allocator@I@std@@@std@@QBEHV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8iterator@?$vector@_NV?$allocator@I@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9iterator@?$vector@_NV?$allocator@I@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Miterator@?$vector@_NV?$allocator@I@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@_NV?$allocator@I@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$vector@_NV?$allocator@I@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$vector@_NV?$allocator@I@std@@@std@@QBE?AVconst_iterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$vector@_NV?$allocator@I@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$vector@_NV?$allocator@I@std@@@std@@QBE?AVconst_iterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$vector@_NV?$allocator@I@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?insert@?$vector@_NV?$allocator@I@std@@@std@@QAE?AViterator@12@V312@_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?insert@?$vector@_NV?$allocator@I@std@@@std@@QAEXViterator@12@I_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?insert@?$vector@_NV?$allocator@I@std@@@std@@QAEXViterator@12@Vconst_iterator@12@1@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$vector@_NV?$allocator@I@std@@@std@@QAE?AViterator@12@V312@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$vector@_NV?$allocator@I@std@@@std@@QAE?AViterator@12@V312@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?swap@?$vector@_NV?$allocator@I@std@@@std@@QAEXAAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Nw@?$vector@_NV?$allocator@I@std@@@std@@KAII@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Trim@?$vector@_NV?$allocator@I@std@@@std@@IAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Xran@?$vector@_NV?$allocator@I@std@@@std@@IBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetRadius@Sphere@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetRadius@Sphere@@QAEXM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Sphere@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?VisibilityCallback@SpherePackCallback@@UAEXABVFrustum@@PAVSpherePack@@W4ViewState@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RayTraceCallback@SpherePackCallback@@UAEXABV?$Vector3d@M@@0M0PAVSpherePack@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RangeTestCallback@SpherePackCallback@@UAEXABV?$Vector3d@M@@MPAVSpherePack@@W4ViewState@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SpherePack@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@SpherePack@@QAEXPAVSpherePackFactory@@ABV?$Vector3d@M@@MPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetSpherePackFlag@SpherePack@@QAEXW4SpherePackFlag@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ClearSpherePackFlag@SpherePack@@QAEXW4SpherePackFlag@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HasSpherePackFlag@SpherePack@@QBE_NW4SpherePackFlag@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetParent@SpherePack@@QAEXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetParent@SpherePack@@QBEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Unlink@SpherePack@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddChild@SpherePack@@QAEXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetNextSibling@SpherePack@@QAEXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetPrevSibling@SpherePack@@QAEXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetNextSibling@SpherePack@@QBEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPrevSibling@SpherePack@@QBEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetChildren@SpherePack@@QBEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetNext@SpherePack@@QBEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPrevious@SpherePack@@QBEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetNext@SpherePack@@QAEXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetPrevious@SpherePack@@QAEXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetUserData@SpherePack@@QBEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetUserData@SpherePack@@QAEXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DistanceSquared@SpherePack@@QBEMPBV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPos@SpherePack@@QBEABV?$Vector3d@M@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetChildCount@SpherePack@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetColor@SpherePack@@QAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetColor@SpherePack@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetFifo1@SpherePack@@QAEXPAPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetFifo2@SpherePack@@QAEXPAPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ComputeBindingDistance@SpherePack@@QAEXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SpherePackFifo@@QAE@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1SpherePackFifo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Push@SpherePackFifo@@QAEPAPAVSpherePack@@PAV2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Pop@SpherePackFifo@@QAEPAVSpherePack@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetCount@SpherePackFifo@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NewPosRadius@SpherePack@@QAEXABV?$Vector3d@M@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SpherePackCallback@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GSpherePackFifo@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Render@SpherePack@@QAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Recompute@SpherePack@@QAE_NM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LostChild@SpherePack@@QAEXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBDABV?$allocator@D@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$basic_ostream@GU?$char_traits@G@std@@@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?put@?$basic_ostream@GU?$char_traits@G@std@@@std@@QAEAAV12@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?flush@?$basic_ostream@GU?$char_traits@G@std@@@std@@QAEAAV12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$basic_ios@GU?$char_traits@G@std@@@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setstate@?$basic_ios@GU?$char_traits@G@std@@@std@@QAEXH_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?rdbuf@?$basic_ios@GU?$char_traits@G@std@@@std@@QBEPAV?$basic_streambuf@GU?$char_traits@G@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$basic_istream@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?overflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pbackfail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?underflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?seekoff@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@JW4seekdir@ios_base@2@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?seekpos@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@V32@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEPAV12@PADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$basic_istream@GU?$char_traits@G@std@@@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0sentry@?$basic_istream@GU?$char_traits@G@std@@@std@@QAE@AAV12@_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Bsentry@?$basic_istream@GU?$char_traits@G@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$basic_streambuf@GU?$char_traits@G@std@@@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?sgetc@?$basic_streambuf@GU?$char_traits@G@std@@@std@@QAEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?snextc@?$basic_streambuf@GU?$char_traits@G@std@@@std@@QAEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?overflow@?$basic_streambuf@GU?$char_traits@G@std@@@std@@MAEGG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pbackfail@?$basic_streambuf@GU?$char_traits@G@std@@@std@@MAEGG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?showmanyc@?$basic_streambuf@GU?$char_traits@G@std@@@std@@MAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?underflow@?$basic_streambuf@GU?$char_traits@G@std@@@std@@MAEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?uflow@?$basic_streambuf@GU?$char_traits@G@std@@@std@@MAEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?xsgetn@?$basic_streambuf@GU?$char_traits@G@std@@@std@@MAEHPAGH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?xsputn@?$basic_streambuf@GU?$char_traits@G@std@@@std@@MAEHPBGH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?seekoff@?$basic_streambuf@GU?$char_traits@G@std@@@std@@MAE?AV?$fpos@H@2@JW4seekdir@ios_base@2@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?seekpos@?$basic_streambuf@GU?$char_traits@G@std@@@std@@MAE?AV?$fpos@H@2@V32@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setbuf@?$basic_streambuf@GU?$char_traits@G@std@@@std@@MAEPAV12@PAGH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?sync@?$basic_streambuf@GU?$char_traits@G@std@@@std@@MAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?imbue@?$basic_streambuf@GU?$char_traits@G@std@@@std@@MAEXABVlocale@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?is@?$ctype@G@std@@QBE_NFG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$ctype@G@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_is@?$ctype@G@std@@MBE_NFG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_is@?$ctype@G@std@@MBEPBGPBG0PAF@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_scan_is@?$ctype@G@std@@MBEPBGFPBG0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_scan_not@?$ctype@G@std@@MBEPBGFPBG0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_tolower@?$ctype@G@std@@MBEGG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_tolower@?$ctype@G@std@@MBEPBGPAGPBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_toupper@?$ctype@G@std@@MBEGG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_toupper@?$ctype@G@std@@MBEPBGPAGPBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_widen@?$ctype@G@std@@MBEGD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_widen@?$ctype@G@std@@MBEPBDPBD0PAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_narrow@?$ctype@G@std@@MBEDGD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_narrow@?$ctype@G@std@@MBEPBGPBG0DPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV?$allocator@I@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$vector@IV?$allocator@I@std@@@std@@QAE@IABIABV?$allocator@I@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?reserve@?$vector@IV?$allocator@I@std@@@std@@QAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$vector@IV?$allocator@I@std@@@std@@QAEPAIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$vector@IV?$allocator@I@std@@@std@@QBEPBIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$vector@IV?$allocator@I@std@@@std@@QAEPAIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?resize@?$vector@IV?$allocator@I@std@@@std@@QAEXIABI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get_allocator@?$vector@IV?$allocator@I@std@@@std@@QBE?AV?$allocator@I@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$vector@IV?$allocator@I@std@@@std@@QAEAAII@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$vector@IV?$allocator@I@std@@@std@@QAEPAIPAI0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Eq@?$vector@IV?$allocator@I@std@@@std@@QBE_NABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lt@?$vector@IV?$allocator@I@std@@@std@@QBE_NABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?swap@?$vector@IV?$allocator@I@std@@@std@@QAEXAAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$reverse_iterator@Viterator@?$vector@_NV?$allocator@I@std@@@std@@_NVreference@23@PAV423@H@std@@QAE@Viterator@?$vector@_NV?$allocator@I@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$reverse_iterator@Vconst_iterator@?$vector@_NV?$allocator@I@std@@@std@@_N$$CBVreference@23@PBV423@H@std@@QAE@Vconst_iterator@?$vector@_NV?$allocator@I@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$Vector3d@M@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$Vector3d@M@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$Vector3d@M@@QAE@MMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$Vector3d@M@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??G?$Vector3d@M@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Y?$Vector3d@M@@QAEXV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??X?$Vector3d@M@@QAEXM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Set@?$Vector3d@M@@QAEXMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Distance@?$Vector3d@M@@QBEMABV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Distance2@?$Vector3d@M@@QBEMABV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Normalize@?$Vector3d@M@@QAEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$Pool@VSpherePack@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$Pool@VSpherePack@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Set@?$Pool@VSpherePack@@@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@?$Pool@VSpherePack@@@@QAEXPAVSpherePack@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetFreeLink@?$Pool@VSpherePack@@@@QAEPAVSpherePack@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$basic_ostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$basic_ios@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$basic_ostream@GU?$char_traits@G@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$basic_ios@GU?$char_traits@G@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$basic_istream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$basic_istream@GU?$char_traits@G@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$basic_streambuf@GU?$char_traits@G@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$ctype@G@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_H@YGXPAXIHP6EX0@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_D?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_D?$basic_ostream@GU?$char_traits@G@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_D?$basic_istream@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_D?$basic_istream@GU?$char_traits@G@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Nullstr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEX_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$fpos@H@std@@QAE@J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$basic_ios@GU?$char_traits@G@std@@@std@@QAEXH_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0sentry@?$basic_ostream@GU?$char_traits@G@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1sentry@?$basic_ostream@GU?$char_traits@G@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Bsentry@?$basic_ostream@GU?$char_traits@G@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?gbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ipfx@?$basic_istream@GU?$char_traits@G@std@@@std@@QAE_N_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pubsync@?$basic_streambuf@GU?$char_traits@G@std@@@std@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?sbumpc@?$basic_streambuf@GU?$char_traits@G@std@@@std@@QAEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?sputc@?$basic_streambuf@GU?$char_traits@G@std@@@std@@QAEGG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?gptr@?$basic_streambuf@GU?$char_traits@G@std@@@std@@IBEPAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pptr@?$basic_streambuf@GU?$char_traits@G@std@@@std@@IBEPAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?egptr@?$basic_streambuf@GU?$char_traits@G@std@@@std@@IBEPAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?gbump@?$basic_streambuf@GU?$char_traits@G@std@@@std@@IAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?epptr@?$basic_streambuf@GU?$char_traits@G@std@@@std@@IBEPAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Gninc@?$basic_streambuf@GU?$char_traits@G@std@@@std@@IAEPAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pbump@?$basic_streambuf@GU?$char_traits@G@std@@@std@@IAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?widen@?$ctype@G@std@@QBEGD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?narrow@?$ctype@G@std@@QBEDGD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@I@std@@QAEPAIIPBX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@I@std@@QAEXPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@I@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$vector@IV?$allocator@I@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$vector@IV?$allocator@I@std@@@std@@QBEPBIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?insert@?$vector@IV?$allocator@I@std@@@std@@QAEXPAIIABI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@IV?$allocator@I@std@@@std@@IAEXPAI0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ucopy@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPBI0PAI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ufill@?$vector@IV?$allocator@I@std@@@std@@IAEXPAIIABI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Length@?$Vector3d@M@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAE_NI_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Refcnt@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAEPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?opfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?opfx@?$basic_ostream@GU?$char_traits@G@std@@@std@@QAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?osfx@?$basic_ostream@GU?$char_traits@G@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?tie@?$basic_ios@GU?$char_traits@G@std@@@std@@QBEPAV?$basic_ostream@GU?$char_traits@G@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Pninc@?$basic_streambuf@GU?$char_traits@G@std@@@std@@IAEPAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@I@std@@QAEXPAIABI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@I@std@@QAEXPAI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Split@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADIPBX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?use_facet@std@@YAABV?$ctype@D@1@ABVlocale@1@PBV21@_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?use_facet@std@@YAABV?$ctype@G@1@ABVlocale@1@PBV21@_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?copy_backward@std@@YA?AViterator@?$vector@_NV?$allocator@I@std@@@1@V231@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?fill@std@@YAXViterator@?$vector@_NV?$allocator@I@std@@@1@0AB_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Distance@std@@YAXVconst_iterator@?$vector@_NV?$allocator@I@std@@@1@0AAI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?copy@std@@YA?AViterator@?$vector@_NV?$allocator@I@std@@@1@Vconst_iterator@31@0V231@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?copy@std@@YA?AViterator@?$vector@_NV?$allocator@I@std@@@1@V231@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?swap@std@@YAXAAI0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?copy@std@@YAPAIPAI00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?equal@std@@YA_NPBI00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lexicographical_compare@std@@YA_NPBI000@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8std@@YA_NABV?$allocator@I@0@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?swap@std@@YAXAAPAI0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8std@@YA_NABV?$allocator@D@0@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Allocate@std@@YAPAIHPAI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?copy@std@@YAPAIPBI0PAI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?fill@std@@YAXPAI0ABI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?copy_backward@std@@YAPAIPAI00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Construct@std@@YAXPAIABI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@std@@YAXPAI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Allocate@std@@YAPADHPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$ctype@G@std@@QAE@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Save@?$_Tidyfac@V?$ctype@D@std@@@std@@SAPAV?$ctype@D@2@PAV32@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Save@?$_Tidyfac@V?$ctype@G@std@@@std@@SAPAV?$ctype@G@2@PAV32@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Init@?$ctype@G@std@@IAEXABV_Locinfo@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$_Tidyfac@V?$ctype@D@std@@@std@@SAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$_Tidyfac@V?$ctype@G@std@@@std@@SAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?id@?$ctype@G@std@@$D
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Iter_cat@std@@YA?AUrandom_access_iterator_tag@1@ABU?$iterator@Urandom_access_iterator_tag@std@@_NH@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Distance@std@@YAXVconst_iterator@?$vector@_NV?$allocator@I@std@@@1@0AAIUrandom_access_iterator_tag@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?mismatch@std@@YA?AU?$pair@PBIPBI@1@PBI00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?id@?$ctype@G@std@@$E
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$pair@PBIPBI@std@@QAE@ABQBI0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R0?AVruntime_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT __CTA2?AVlogic_error@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __TI2?AVbad_typeid@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __TI2?AVbad_cast@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CTA3?AVrange_error@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVout_of_range@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT __CTA3?AVfailure@ios_base@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVoverflow_error@std@@@8??0overflow_error@std@@QAE@ABV01@@Z28
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_7SpherePackFactory@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __CTA2?AVruntime_error@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __TI3?AVunderflow_error@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CTA3?AVoverflow_error@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVrange_error@std@@@8??0range_error@std@@QAE@ABV01@@Z28
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z28
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ?_Psave@?1??use_facet@std@@YAABV?$ctype@G@2@ABVlocale@2@PBV32@_N@Z@4PBVfacet@42@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT __CTA3?AVdomain_error@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QAE@ABV012@@Z28
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_exception@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __TI2?AVruntime_error@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __TI3?AVout_of_range@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_typeid@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT __CTA3?AVunderflow_error@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __TI3?AVrange_error@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_cast@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVoverflow_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_7?$basic_ios@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$codecvt@GDH@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7__non_rtti_object@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_8?$basic_istream@DU?$char_traits@D@std@@@std@@7B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$basic_ios@GU?$char_traits@G@std@@@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$basic_istream@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7bad_cast@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$basic_istream@GU?$char_traits@G@std@@@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7facet@locale@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_8?$basic_istream@GU?$char_traits@G@std@@@std@@7B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7range_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7runtime_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7underflow_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$ctype@D@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_8?$basic_ostream@DU?$char_traits@D@std@@@std@@7B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$basic_streambuf@GU?$char_traits@G@std@@@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ios_base@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7domain_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7failure@ios_base@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$basic_ostream@GU?$char_traits@G@std@@@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7overflow_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7bad_typeid@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ctype_base@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7out_of_range@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$ctype@G@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7invalid_argument@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Facsav@?$_Tidyfac@V?$ctype@D@std@@@std@@0PAV?$ctype@D@2@A
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_Facsav@?$_Tidyfac@V?$ctype@G@std@@@std@@0PAV?$ctype@G@2@A
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_8?$basic_ostream@GU?$char_traits@G@std@@@std@@7B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7bad_exception@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7codecvt_base@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __TI3?AVfailure@ios_base@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __TI3?AVinvalid_argument@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVexception@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT __CT??_R0?AVbad_typeid@std@@@8??0bad_typeid@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z28
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __TI3?AVdomain_error@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_cast@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT __CTA3?AVinvalid_argument@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ?_Psave@?1??use_facet@std@@YAABV?$ctype@D@2@ABVlocale@2@PBV32@_N@Z@4PBVfacet@42@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVunderflow_error@std@@@8??0underflow_error@std@@QAE@ABV01@@Z28
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVdomain_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVunderflow_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_7SpherePackCallback@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __CT??_R0?AVinvalid_argument@std@@@8??0invalid_argument@std@@QAE@ABV01@@Z28
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_exception@std@@@8??0bad_exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVfailure@ios_base@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT __TI2?AVlogic_error@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __TI3?AVoverflow_error@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVdomain_error@std@@@8??0domain_error@std@@QAE@ABV01@@Z28
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z28
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_typeid@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVinvalid_argument@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVrange_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT __TI2?AVbad_exception@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ?_C@?1??_Nullstr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPBDXZ@4DB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z28
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_exception@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT __CTA3?AVout_of_range@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
FLAT	GROUP _DATA, CONST, _BSS, CRT$XCA, CRT$XCU, CRT$XCL, CRT$XCC, CRT$XCZ, xdata$x
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
CRT$XCU	SEGMENT
_$S18	DD	FLAT:_$E17
_$S24	DD	FLAT:_$E23
_$S32	DD	FLAT:_$E31
CRT$XCU	ENDS
PUBLIC	??_H@YGXPAXIHP6EX0@Z@Z				; `vector constructor iterator'
PUBLIC	??0SpherePackFactory@@QAE@HMMM@Z		; SpherePackFactory::SpherePackFactory
PUBLIC	?RayTraceCallback@SpherePackFactory@@UAEXABV?$Vector3d@M@@0M0PAVSpherePack@@@Z ; SpherePackFactory::RayTraceCallback
PUBLIC	?RangeTestCallback@SpherePackFactory@@UAEXABV?$Vector3d@M@@MPAVSpherePack@@W4ViewState@@@Z ; SpherePackFactory::RangeTestCallback
PUBLIC	?VisibilityCallback@SpherePackFactory@@UAEXABVFrustum@@PAVSpherePack@@W4ViewState@@@Z ; SpherePackFactory::VisibilityCallback
PUBLIC	??1?$Pool@VSpherePack@@@@QAE@XZ			; Pool<SpherePack>::~Pool<SpherePack>
PUBLIC	??_7SpherePackFactory@@6B@			; SpherePackFactory::`vftable'
PUBLIC	??4?$Vector3d@M@@QAEAAV0@ABV0@@Z		; Vector3d<float>::operator=
PUBLIC	??0SpherePack@@QAE@XZ				; SpherePack::SpherePack
PUBLIC	?Init@SpherePack@@QAEXPAVSpherePackFactory@@ABV?$Vector3d@M@@MPAX@Z ; SpherePack::Init
EXTRN	??2@YAPAXI@Z:NEAR				; operator new
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
EXTRN	__except_list:DWORD
EXTRN	__fltused:NEAR
EXTRN	___CxxFrameHandler:NEAR
;	COMDAT ??_7SpherePackFactory@@6B@
; File C:\WINDOWS\Desktop\Gems2 CD\SourceCode\04 Geometry Management\03 Ratcliff\spherepack.h
CONST	SEGMENT
??_7SpherePackFactory@@6B@ DD FLAT:?VisibilityCallback@SpherePackFactory@@UAEXABVFrustum@@PAVSpherePack@@W4ViewState@@@Z ; SpherePackFactory::`vftable'
	DD	FLAT:?RayTraceCallback@SpherePackFactory@@UAEXABV?$Vector3d@M@@0M0PAVSpherePack@@@Z
	DD	FLAT:?RangeTestCallback@SpherePackFactory@@UAEXABV?$Vector3d@M@@MPAVSpherePack@@W4ViewState@@@Z
CONST	ENDS
xdata$x	SEGMENT
$T14839	DD	019930520H
	DD	04H
	DD	FLAT:$T14847
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T14847	DD	0ffffffffH
	DD	FLAT:$L14669
	DD	00H
	DD	FLAT:$L14670
	DD	00H
	DD	FLAT:$L14671
	DD	00H
	DD	FLAT:$L14695
xdata$x	ENDS
_TEXT	SEGMENT
$T14662 = 12
$T14666 = 12
_maxspheres$ = 8
_rootsize$ = 12
_leafsize$ = 16
_gravy$ = 20
_this$ = -16
$T14730 = 12
_p$ = -28
__$EHRec$ = -12
??0SpherePackFactory@@QAE@HMMM@Z PROC NEAR		; SpherePackFactory::SpherePackFactory

; 27   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	$L14844
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	mov	esi, ecx
	xor	ebx, ebx
	push	edi
	mov	DWORD PTR _this$[ebp], esi
	mov	DWORD PTR [esi+28], ebx
	mov	DWORD PTR [esi+32], ebx
	mov	DWORD PTR [esi+24], ebx
	mov	DWORD PTR [esi+20], ebx
	mov	DWORD PTR [esi+40], ebx
	mov	DWORD PTR [esi+36], ebx

; 28   :   maxspheres*=4; // include room for both trees, the root node and leaf node tree, and the supersheres

	mov	eax, DWORD PTR _maxspheres$[ebp]

; 29   :   mMaxRootSize      = rootsize;

	mov	ecx, DWORD PTR _rootsize$[ebp]

; 30   :   mMaxLeafSize      = leafsize;

	mov	edx, DWORD PTR _leafsize$[ebp]

; 31   :   mSuperSphereGravy = gravy;
; 32   :   mIntegrate        = new SpherePackFifo(maxspheres);

	push	20					; 00000014H
	lea	edi, DWORD PTR [eax*4]
	mov	eax, DWORD PTR _gravy$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], ebx
	mov	DWORD PTR [esi], OFFSET FLAT:??_7SpherePackFactory@@6B@ ; SpherePackFactory::`vftable'
	mov	DWORD PTR _maxspheres$[ebp], edi
	mov	DWORD PTR [esi+104], ecx
	mov	DWORD PTR [esi+108], edx
	mov	DWORD PTR [esi+112], eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T14662[ebp], eax
	cmp	eax, ebx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	je	SHORT $L14663
	lea	ecx, DWORD PTR [edi*4]
	mov	DWORD PTR [eax], ebx
	push	ecx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], edi
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, DWORD PTR $T14662[ebp]
	add	esp, 4
	mov	DWORD PTR [ecx+16], eax
	mov	eax, ecx
	jmp	SHORT $L14664
$L14663:
	xor	eax, eax
$L14664:

; 33   :   mRecompute        = new SpherePackFifo(maxspheres);

	push	20					; 00000014H
	mov	BYTE PTR __$EHRec$[ebp+8], bl
	mov	DWORD PTR [esi+44], eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T14666[ebp], eax
	cmp	eax, ebx
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	je	SHORT $L14667
	lea	edx, DWORD PTR [edi*4]
	mov	DWORD PTR [eax], ebx
	push	edx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], edi
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, DWORD PTR $T14666[ebp]
	add	esp, 4
	mov	DWORD PTR [ecx+16], eax
	mov	eax, ecx
	jmp	SHORT $L14668
$L14667:
	xor	eax, eax
$L14668:
	mov	DWORD PTR [esi+48], eax

; 34   : 
; 35   :   mSpheres.Set(maxspheres);       // init pool to hold all possible SpherePack instances.

	mov	eax, DWORD PTR [esi+24]
	push	eax
	mov	BYTE PTR __$EHRec$[ebp+8], bl
	call	??3@YAXPAX@Z				; operator delete
	lea	eax, DWORD PTR [edi+edi*8]
	mov	DWORD PTR [esi+16], edi
	lea	ecx, DWORD PTR [edi+eax*2]
	shl	ecx, 2
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T14730[ebp], eax
	cmp	eax, ebx
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	je	SHORT $L14731
	push	OFFSET FLAT:??0SpherePack@@QAE@XZ	; SpherePack::SpherePack
	push	edi
	push	76					; 0000004cH
	push	eax
	call	??_H@YGXPAXIHP6EX0@Z@Z			; `vector constructor iterator'
	mov	eax, DWORD PTR $T14730[ebp]
	jmp	SHORT $L14732
$L14731:
	xor	eax, eax
$L14732:
	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR [esi+24], eax
	mov	DWORD PTR [esi+32], eax
	xor	eax, eax
	dec	edx
	mov	BYTE PTR __$EHRec$[ebp+8], bl
	test	edx, edx
	mov	DWORD PTR [esi+28], ebx
	jle	SHORT $L14724
$L14722:
	mov	edx, DWORD PTR [esi+24]
	lea	ecx, DWORD PTR [eax+eax*8]

; 54   :   mColorCount = 0;
; 55   : 
; 56   :   mColors[0]  = 0x00FF0000;
; 57   :   mColors[1]  = 0x0000FF00;
; 58   :   mColors[2]  = 0x000000FF;
; 59   :   mColors[3]  = 0x00FFFF00;
; 60   :   mColors[4]  = 0x00FF00FF;
; 61   :   mColors[5]  = 0x0000FFFF;
; 62   :   mColors[6]  = 0x00FF8080;
; 63   :   mColors[7]  = 0x0000FF80;
; 64   :   mColors[8]  = 0x000080FF;
; 65   :   mColors[9]  = 0x00FFFF80;
; 66   :   mColors[10] = 0x00FF80FF;
; 67   :   mColors[11] = 0x0080FFFF;
; 68   : 
; 69   :   #endif
; 70   : }

	lea	edi, DWORD PTR [eax+eax*8+9]
	lea	ecx, DWORD PTR [eax+ecx*2]
	lea	edi, DWORD PTR [eax+edi*2+1]
	shl	ecx, 2
	lea	edi, DWORD PTR [edx+edi*4]
	cmp	eax, ebx
	mov	DWORD PTR [ecx+edx+20], edi
	mov	edx, DWORD PTR [esi+24]
	jne	SHORT $L14725

; 34   : 
; 35   :   mSpheres.Set(maxspheres);       // init pool to hold all possible SpherePack instances.

	mov	DWORD PTR [edx+24], ebx
	jmp	SHORT $L14723
$L14725:

; 54   :   mColorCount = 0;
; 55   : 
; 56   :   mColors[0]  = 0x00FF0000;
; 57   :   mColors[1]  = 0x0000FF00;
; 58   :   mColors[2]  = 0x000000FF;
; 59   :   mColors[3]  = 0x00FFFF00;
; 60   :   mColors[4]  = 0x00FF00FF;
; 61   :   mColors[5]  = 0x0000FFFF;
; 62   :   mColors[6]  = 0x00FF8080;
; 63   :   mColors[7]  = 0x0000FF80;
; 64   :   mColors[8]  = 0x000080FF;
; 65   :   mColors[9]  = 0x00FFFF80;
; 66   :   mColors[10] = 0x00FF80FF;
; 67   :   mColors[11] = 0x0080FFFF;
; 68   : 
; 69   :   #endif
; 70   : }

	add	ecx, edx
	lea	edx, DWORD PTR [ecx-76]
	mov	DWORD PTR [ecx+24], edx
$L14723:
	mov	ecx, DWORD PTR [esi+16]
	inc	eax
	dec	ecx
	cmp	eax, ecx
	jl	SHORT $L14722

; 34   : 
; 35   :   mSpheres.Set(maxspheres);       // init pool to hold all possible SpherePack instances.

	mov	edi, DWORD PTR _maxspheres$[ebp]
$L14724:
	mov	ecx, DWORD PTR [esi+24]
	lea	edx, DWORD PTR [eax+eax*8]
	lea	eax, DWORD PTR [eax+edx*2]
	shl	eax, 2
	mov	DWORD PTR [eax+ecx+20], ebx

; 54   :   mColorCount = 0;
; 55   : 
; 56   :   mColors[0]  = 0x00FF0000;
; 57   :   mColors[1]  = 0x0000FF00;
; 58   :   mColors[2]  = 0x000000FF;
; 59   :   mColors[3]  = 0x00FFFF00;
; 60   :   mColors[4]  = 0x00FF00FF;
; 61   :   mColors[5]  = 0x0000FFFF;
; 62   :   mColors[6]  = 0x00FF8080;
; 63   :   mColors[7]  = 0x0000FF80;
; 64   :   mColors[8]  = 0x000080FF;
; 65   :   mColors[9]  = 0x00FFFF80;
; 66   :   mColors[10] = 0x00FF80FF;
; 67   :   mColors[11] = 0x0080FFFF;
; 68   : 
; 69   :   #endif
; 70   : }

	mov	edx, DWORD PTR [esi+24]
	add	eax, edx
	lea	ecx, DWORD PTR [eax-76]
	mov	DWORD PTR [eax+24], ecx
	mov	DWORD PTR [esi+20], ebx
	mov	DWORD PTR [esi+40], edi
	mov	DWORD PTR [esi+36], ebx
	mov	edi, DWORD PTR [esi+32]
	mov	DWORD PTR _p$[ebp], 0
	cmp	edi, ebx
	mov	DWORD PTR _p$[ebp+4], 0
	mov	DWORD PTR _p$[ebp+8], 0
	jne	SHORT $L14764

; 36   : 
; 37   :   Vector3d<float> p(0,0,0);
; 38   : 
; 39   :   mRoot = mSpheres.GetFreeLink(); // initially empty

	xor	edi, edi
	jmp	SHORT $L14763
$L14764:
	mov	eax, DWORD PTR [esi+28]
	mov	edx, DWORD PTR [edi+20]
	cmp	eax, ebx
	mov	DWORD PTR [esi+32], edx
	mov	DWORD PTR [esi+28], edi
	je	SHORT $L14771
	mov	DWORD PTR [eax+24], edi
$L14771:
	mov	ecx, DWORD PTR [esi+28]
	mov	DWORD PTR [ecx+20], eax
	mov	edx, DWORD PTR [esi+28]
	mov	DWORD PTR [edx+24], ebx
	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [esi+40]
	inc	ecx
	dec	eax
	mov	DWORD PTR [esi+36], ecx
	mov	DWORD PTR [esi+40], eax
$L14763:

; 40   :   mRoot->Init(this,p,65536,0);

	lea	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR [esi+4], edi
	push	eax
	mov	ecx, edi
	mov	DWORD PTR [edi+64], ebx
	mov	DWORD PTR [edi+28], ebx
	mov	DWORD PTR [edi+36], ebx
	mov	DWORD PTR [edi+40], ebx
	mov	DWORD PTR [edi+52], ebx
	mov	DWORD PTR [edi+44], ebx
	mov	DWORD PTR [edi+48], ebx
	mov	DWORD PTR [edi+68], esi
	call	??4?$Vector3d@M@@QAEAAV0@ABV0@@Z	; Vector3d<float>::operator=
	mov	DWORD PTR [edi+12], 1199570944		; 47800000H
	mov	DWORD PTR [edi+16], 1333788672		; 4f800000H

; 41   :   mRoot->SetSpherePackFlag( SpherePackFlag(SPF_SUPERSPHERE | SPF_ROOTNODE | SPF_ROOT_TREE) );

	mov	eax, DWORD PTR [esi+4]

; 42   : 
; 43   :   #if DEMO
; 44   :   mRoot->SetColor(0x00FFFFFF);

	mov	edi, 16777215				; 00ffffffH
	mov	edx, DWORD PTR [eax+52]
	or	edx, 11					; 0000000bH
	mov	DWORD PTR [eax+52], edx
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+72], edi

; 45   :   #endif
; 46   : 
; 47   :   mLeaf = mSpheres.GetFreeLink();; // initially empty

	mov	eax, DWORD PTR [esi+32]
	cmp	eax, ebx
	jne	SHORT $L14813
	xor	eax, eax
	jmp	SHORT $L14812
$L14813:
	mov	ecx, DWORD PTR [esi+28]
	mov	edx, DWORD PTR [eax+20]
	cmp	ecx, ebx
	mov	DWORD PTR [esi+32], edx
	mov	DWORD PTR [esi+28], eax
	je	SHORT $L14820
	mov	DWORD PTR [ecx+24], eax
$L14820:
	mov	edx, DWORD PTR [esi+28]
	mov	DWORD PTR [edx+20], ecx
	mov	ecx, DWORD PTR [esi+28]
	mov	DWORD PTR [ecx+24], ebx
	mov	edx, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [esi+40]
	inc	edx
	dec	ecx
	mov	DWORD PTR [esi+36], edx
	mov	DWORD PTR [esi+40], ecx
$L14812:

; 48   :   mLeaf->Init(this,p,16384,0);

	push	ebx
	lea	edx, DWORD PTR _p$[ebp]
	push	1182793728				; 46800000H
	push	edx
	push	esi
	mov	ecx, eax
	mov	DWORD PTR [esi+8], eax
	call	?Init@SpherePack@@QAEXPAVSpherePackFactory@@ABV?$Vector3d@M@@MPAX@Z ; SpherePack::Init

; 49   :   mLeaf->SetSpherePackFlag( SpherePackFlag(SPF_SUPERSPHERE | SPF_ROOTNODE | SPF_LEAF_TREE) );

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [eax+52]
	or	ecx, 13					; 0000000dH
	mov	DWORD PTR [eax+52], ecx

; 50   : 
; 51   :   #if DEMO
; 52   : 
; 53   :   mLeaf->SetColor(0x00FFFFFF);

	mov	eax, DWORD PTR [esi+8]

; 54   :   mColorCount = 0;
; 55   : 
; 56   :   mColors[0]  = 0x00FF0000;
; 57   :   mColors[1]  = 0x0000FF00;
; 58   :   mColors[2]  = 0x000000FF;
; 59   :   mColors[3]  = 0x00FFFF00;
; 60   :   mColors[4]  = 0x00FF00FF;
; 61   :   mColors[5]  = 0x0000FFFF;
; 62   :   mColors[6]  = 0x00FF8080;
; 63   :   mColors[7]  = 0x0000FF80;
; 64   :   mColors[8]  = 0x000080FF;
; 65   :   mColors[9]  = 0x00FFFF80;
; 66   :   mColors[10] = 0x00FF80FF;
; 67   :   mColors[11] = 0x0080FFFF;
; 68   : 
; 69   :   #endif
; 70   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR [eax+72], edi
	mov	DWORD PTR [esi+52], ebx
	mov	DWORD PTR [esi+56], 16711680		; 00ff0000H
	mov	DWORD PTR [esi+60], 65280		; 0000ff00H
	mov	DWORD PTR [esi+64], 255			; 000000ffH
	mov	DWORD PTR [esi+68], 16776960		; 00ffff00H
	mov	DWORD PTR [esi+72], 16711935		; 00ff00ffH
	mov	DWORD PTR [esi+76], 65535		; 0000ffffH
	mov	DWORD PTR [esi+80], 16744576		; 00ff8080H
	mov	DWORD PTR [esi+84], 65408		; 0000ff80H
	mov	DWORD PTR [esi+88], 33023		; 000080ffH
	mov	DWORD PTR [esi+92], 16777088		; 00ffff80H
	mov	DWORD PTR [esi+96], 16744703		; 00ff80ffH
	mov	DWORD PTR [esi+100], 8454143		; 0080ffffH
	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
text$x	SEGMENT
$L14669:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	jmp	??1?$Pool@VSpherePack@@@@QAE@XZ		; Pool<SpherePack>::~Pool<SpherePack>
$L14670:
	mov	eax, DWORD PTR $T14662[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
$L14671:
	mov	eax, DWORD PTR $T14666[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
$L14695:
	mov	eax, DWORD PTR $T14730[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
$L14844:
	mov	eax, OFFSET FLAT:$T14839
	jmp	___CxxFrameHandler
text$x	ENDS
??0SpherePackFactory@@QAE@HMMM@Z ENDP			; SpherePackFactory::SpherePackFactory
PUBLIC	??1SpherePackFactory@@QAE@XZ			; SpherePackFactory::~SpherePackFactory
_TEXT	SEGMENT
??1SpherePackFactory@@QAE@XZ PROC NEAR			; SpherePackFactory::~SpherePackFactory

; 73   : {

	push	esi
	mov	esi, ecx
	push	edi

; 74   :   delete mIntegrate;  // free up integration fifo

	mov	edi, DWORD PTR [esi+44]
	mov	DWORD PTR [esi], OFFSET FLAT:??_7SpherePackFactory@@6B@ ; SpherePackFactory::`vftable'
	test	edi, edi
	je	SHORT $L14852
	mov	eax, DWORD PTR [edi+16]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 8
$L14852:

; 75   :   delete mRecompute;  // free up recomputation fifo.

	mov	edi, DWORD PTR [esi+48]
	test	edi, edi
	je	SHORT $L14856
	mov	ecx, DWORD PTR [edi+16]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 8
$L14856:

; 76   : }

	mov	edx, DWORD PTR [esi+24]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	pop	edi
	pop	esi
	ret	0
??1SpherePackFactory@@QAE@XZ ENDP			; SpherePackFactory::~SpherePackFactory
_TEXT	ENDS
PUBLIC	?Unlink@SpherePack@@QAEXXZ			; SpherePack::Unlink
PUBLIC	?ComputeBindingDistance@SpherePack@@QAEXPAV1@@Z	; SpherePack::ComputeBindingDistance
PUBLIC	?Process@SpherePackFactory@@QAEXXZ		; SpherePackFactory::Process
PUBLIC	?Integrate@SpherePackFactory@@QAEXPAVSpherePack@@0M@Z ; SpherePackFactory::Integrate
PUBLIC	?Remove@SpherePackFactory@@QAEXPAVSpherePack@@@Z ; SpherePackFactory::Remove
PUBLIC	?Release@?$Pool@VSpherePack@@@@QAEXPAVSpherePack@@@Z ; Pool<SpherePack>::Release
PUBLIC	__real@4@3fff8000000000000000
PUBLIC	??0?$Vector3d@M@@QAE@ABV0@@Z			; Vector3d<float>::Vector3d<float>
PUBLIC	??Y?$Vector3d@M@@QAEXV0@@Z			; Vector3d<float>::operator+=
PUBLIC	??X?$Vector3d@M@@QAEXM@Z			; Vector3d<float>::operator*=
PUBLIC	?Distance2@?$Vector3d@M@@QBEMABV1@@Z		; Vector3d<float>::Distance2
;	COMDAT __real@4@3fff8000000000000000
; File C:\WINDOWS\Desktop\Gems2 CD\SourceCode\04 Geometry Management\03 Ratcliff\spherepack.h
CONST	SEGMENT
__real@4@3fff8000000000000000 DD 03f800000r	; 1
CONST	ENDS
_TEXT	SEGMENT
_this$ = -4
_maxrecompute$12704 = -24
_i$12705 = -16
_maxintegrate$12714 = -24
_i$12715 = -16
_total$14949 = -36
_count$14950 = -20
_oldpos$14956 = -48
_maxradius$14957 = -8
$T14993 = -12
?Process@SpherePackFactory@@QAEXXZ PROC NEAR		; SpherePackFactory::Process

; 79   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	edx, ecx
	push	ebx
	push	esi
	push	edi

; 80   :   if ( 1 )
; 81   :   {
; 82   :     // First recompute anybody that needs to be recomputed!!
; 83   :     // When leaf node spheres exit their parent sphere, then the parent sphere needs to be rebalanced.  In fact,it may now be empty and
; 84   :     // need to be removed.
; 85   :     // This is the location where (n) number of spheres in the recomputation FIFO are allowed to be rebalanced in the tree.
; 86   :     int maxrecompute = mRecompute->GetCount();

	mov	eax, DWORD PTR [edx+48]
	mov	DWORD PTR _this$[ebp], edx

; 87   :     for (int i=0; i<maxrecompute; i++)

	mov	DWORD PTR _i$12705[ebp], 0
	mov	eax, DWORD PTR [eax]
	test	eax, eax
	mov	DWORD PTR _maxrecompute$12704[ebp], eax
	jle	$L15069
	jmp	SHORT $L12706
$L15079:
	mov	edx, DWORD PTR _this$[ebp]
$L12706:

; 88   :     {
; 89   :       SpherePack *pack = mRecompute->Pop();

	mov	eax, DWORD PTR [edx+48]
	mov	ebx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+8]
	cmp	ebx, ecx
	je	$L15069
	mov	edx, DWORD PTR [eax+16]
	mov	edi, DWORD PTR [eax+12]
$L14894:
	mov	esi, DWORD PTR [eax]
	dec	esi
	inc	ecx
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [edx+ecx*4-4]
	cmp	ecx, edi
	mov	DWORD PTR [eax+8], ecx
	jne	SHORT $L14897
	mov	DWORD PTR [eax+8], 0
$L14897:
	test	esi, esi
	jne	SHORT $L15071
	mov	ecx, DWORD PTR [eax+8]
	cmp	ebx, ecx
	je	$L15081
	jmp	SHORT $L14894
$L15071:

; 90   :       if ( !pack ) break;
; 91   :       pack->SetFifo1(0); // no longer on the fifo!!
; 92   :       bool kill = pack->Recompute(mSuperSphereGravy);

	mov	ebx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [esi+44], 0
	mov	edi, DWORD PTR [esi+32]
	mov	ecx, DWORD PTR [ebx+112]
	test	edi, edi
	mov	DWORD PTR $T14993[ebp], ecx
	je	$L15063
	test	BYTE PTR [esi+52], 8
	jne	$L12707
	xor	ebx, ebx
	mov	DWORD PTR _total$14949[ebp], 0
	test	edi, edi
	mov	DWORD PTR _total$14949[ebp+4], 0
	mov	DWORD PTR _total$14949[ebp+8], 0
	je	$L14965
$L14952:
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	push	edi
	call	??0?$Vector3d@M@@QAE@ABV0@@Z		; Vector3d<float>::Vector3d<float>
	lea	ecx, DWORD PTR _total$14949[ebp]
	call	??Y?$Vector3d@M@@QAEXV0@@Z		; Vector3d<float>::operator+=
	mov	edi, DWORD PTR [edi+36]
	inc	ebx
	test	edi, edi
	jne	SHORT $L14952
	test	ebx, ebx
	mov	DWORD PTR _count$14950[ebp], ebx
	je	$L14965
	fild	DWORD PTR _count$14950[ebp]
	push	ecx
	lea	ecx, DWORD PTR _total$14949[ebp]
	fdivr	DWORD PTR __real@4@3fff8000000000000000
	fstp	DWORD PTR [esp]
	call	??X?$Vector3d@M@@QAEXM@Z		; Vector3d<float>::operator*=
	push	esi
	lea	ecx, DWORD PTR _oldpos$14956[ebp]
	call	??0?$Vector3d@M@@QAE@ABV0@@Z		; Vector3d<float>::Vector3d<float>
	lea	edx, DWORD PTR _total$14949[ebp]
	mov	ecx, esi
	push	edx
	call	??4?$Vector3d@M@@QAEAAV0@ABV0@@Z	; Vector3d<float>::operator=
	mov	DWORD PTR _maxradius$14957[ebp], edi
	mov	edi, DWORD PTR [esi+32]
	test	edi, edi
	je	SHORT $L14959
$L14958:
	push	edi
	mov	ecx, esi
	call	?Distance2@?$Vector3d@M@@QBEMABV1@@Z	; Vector3d<float>::Distance2
	fsqrt
	fadd	DWORD PTR [edi+12]
	fcom	DWORD PTR _maxradius$14957[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L15075
	fst	DWORD PTR _maxradius$14957[ebp]
	fadd	DWORD PTR $T14993[ebp]
	fld	DWORD PTR [esi+12]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L15057
	jmp	SHORT $L14963
$L15075:
	fstp	ST(0)
$L14963:
	mov	edi, DWORD PTR [edi+36]
	test	edi, edi
	jne	SHORT $L14958
$L14959:
	fld	DWORD PTR _maxradius$14957[ebp]
	fadd	DWORD PTR $T14993[ebp]
	fst	DWORD PTR [esi+12]
	fld	ST(0)
	fmul	ST(0), ST(1)
	fstp	DWORD PTR [esi+16]
	mov	edi, DWORD PTR [esi+32]
	test	edi, edi
	fstp	ST(0)
	je	SHORT $L14965
$L14964:
	push	esi
	mov	ecx, edi
	call	?ComputeBindingDistance@SpherePack@@QAEXPAV1@@Z ; SpherePack::ComputeBindingDistance
	mov	edi, DWORD PTR [edi+36]
	test	edi, edi
	jne	SHORT $L14964
$L14965:
	mov	eax, DWORD PTR [esi+52]
	and	al, -17					; ffffffefH
	mov	DWORD PTR [esi+52], eax

; 93   :       if ( kill ) Remove(pack);

	jmp	SHORT $L12707
$L15057:

; 90   :       if ( !pack ) break;
; 91   :       pack->SetFifo1(0); // no longer on the fifo!!
; 92   :       bool kill = pack->Recompute(mSuperSphereGravy);

	lea	eax, DWORD PTR _oldpos$14956[ebp]
	mov	ecx, esi
	push	eax
	call	??4?$Vector3d@M@@QAEAAV0@ABV0@@Z	; Vector3d<float>::operator=
	mov	eax, DWORD PTR [esi+52]
	and	al, -17					; ffffffefH
	mov	DWORD PTR [esi+52], eax
	jmp	SHORT $L12707
$L15063:

; 93   :       if ( kill ) Remove(pack);

	mov	eax, DWORD PTR [esi+52]
	test	al, 8
	jne	SHORT $L12707
	test	al, 1
	je	SHORT $L15015
	test	al, 4
	je	SHORT $L15015
	mov	ecx, DWORD PTR [esi+64]
	push	ecx
	mov	ecx, ebx
	call	?Remove@SpherePackFactory@@QAEXPAVSpherePack@@@Z ; SpherePackFactory::Remove
$L15015:
	mov	ecx, esi
	call	?Unlink@SpherePack@@QAEXXZ		; SpherePack::Unlink
	push	esi
	lea	ecx, DWORD PTR [ebx+16]
	call	?Release@?$Pool@VSpherePack@@@@QAEXPAVSpherePack@@@Z ; Pool<SpherePack>::Release
$L12707:
	mov	eax, DWORD PTR _i$12705[ebp]
	mov	ecx, DWORD PTR _maxrecompute$12704[ebp]
	inc	eax
	cmp	eax, ecx
	mov	DWORD PTR _i$12705[ebp], eax
	jl	$L15079
$L15081:

; 87   :     for (int i=0; i<maxrecompute; i++)

	mov	edx, DWORD PTR _this$[ebp]
$L15069:

; 94   :     }
; 95   :   }
; 96   : 
; 97   :   if ( 1 )
; 98   :   {
; 99   :     // Now, process the integration step.
; 100  : 
; 101  :     int maxintegrate = mIntegrate->GetCount();

	mov	eax, DWORD PTR [edx+44]

; 102  : 
; 103  :     for (int i=0; i<maxintegrate; i++)

	mov	DWORD PTR _i$12715[ebp], 0
	mov	eax, DWORD PTR [eax]
	test	eax, eax
	mov	DWORD PTR _maxintegrate$12714[ebp], eax
	jle	SHORT $L15070
	jmp	SHORT $L12716
$L15082:
	mov	edx, DWORD PTR _this$[ebp]
$L12716:

; 104  :     {
; 105  :       SpherePack *pack = mIntegrate->Pop();

	mov	eax, DWORD PTR [edx+44]
	mov	ebx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+8]
	cmp	ebx, ecx
	je	SHORT $L15070
	mov	esi, DWORD PTR [eax+16]
	mov	edi, DWORD PTR [eax+12]
$L15034:
	mov	edx, DWORD PTR [eax]
	dec	edx
	inc	ecx
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [esi+ecx*4-4]
	cmp	ecx, edi
	mov	DWORD PTR [eax+8], ecx
	jne	SHORT $L15037
	mov	DWORD PTR [eax+8], 0
$L15037:
	test	edx, edx
	jne	SHORT $L15072
	mov	ecx, DWORD PTR [eax+8]
	cmp	ebx, ecx
	je	SHORT $L15070
	jmp	SHORT $L15034
$L15072:

; 106  :       if ( !pack ) break;
; 107  :       pack->SetFifo2(0);
; 108  : 
; 109  :       if ( pack->HasSpherePackFlag(SPF_ROOT_TREE) )
; 110  :         Integrate(pack,mRoot,mMaxRootSize); // integrate this one single dude against the root node.

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+48], 0
	test	BYTE PTR [edx+52], 2
	je	SHORT $L12721
	mov	eax, DWORD PTR [ecx+104]
	push	eax
	mov	eax, DWORD PTR [ecx+4]

; 111  :       else

	jmp	SHORT $L15084
$L12721:

; 112  :         Integrate(pack,mLeaf,mMaxLeafSize); // integrate this one single dude against the root node.

	mov	eax, DWORD PTR [ecx+108]
	push	eax
	mov	eax, DWORD PTR [ecx+8]
$L15084:
	push	eax
	push	edx
	call	?Integrate@SpherePackFactory@@QAEXPAVSpherePack@@0M@Z ; SpherePackFactory::Integrate
	mov	eax, DWORD PTR _i$12715[ebp]
	mov	ecx, DWORD PTR _maxintegrate$12714[ebp]
	inc	eax
	cmp	eax, ecx
	mov	DWORD PTR _i$12715[ebp], eax
	jl	SHORT $L15082
$L15070:

; 113  :     }
; 114  :   }
; 115  : 
; 116  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Process@SpherePackFactory@@QAEXXZ ENDP			; SpherePackFactory::Process
_TEXT	ENDS
PUBLIC	?AddChild@SpherePack@@QAEXPAV1@@Z		; SpherePack::AddChild
PUBLIC	?Push@SpherePackFifo@@QAEPAPAVSpherePack@@PAV2@@Z ; SpherePackFifo::Push
PUBLIC	?AddSphere@SpherePackFactory@@QAEPAVSpherePack@@ABV?$Vector3d@M@@MPAXH@Z ; SpherePackFactory::AddSphere
_TEXT	SEGMENT
_pos$ = 8
_radius$ = 12
_userdata$ = 16
_flags$ = 20
?AddSphere@SpherePackFactory@@QAEPAVSpherePack@@ABV?$Vector3d@M@@MPAXH@Z PROC NEAR ; SpherePackFactory::AddSphere

; 123  : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	edi, ecx

; 124  : 
; 125  :   SpherePack *pack = mSpheres.GetFreeLink();

	xor	eax, eax
	mov	esi, DWORD PTR [edi+32]
	cmp	esi, eax
	je	$L15323
	mov	ecx, DWORD PTR [esi+20]
	mov	DWORD PTR [edi+32], ecx
	mov	ecx, DWORD PTR [edi+28]
	cmp	ecx, eax
	mov	DWORD PTR [edi+28], esi
	je	SHORT $L15110
	mov	DWORD PTR [ecx+24], esi
$L15110:
	mov	edx, DWORD PTR [edi+28]
	mov	DWORD PTR [edx+20], ecx
	mov	ecx, DWORD PTR [edi+28]
	mov	DWORD PTR [ecx+24], eax
	mov	ebx, DWORD PTR [edi+36]
	mov	edx, DWORD PTR [edi+40]
	inc	ebx
	dec	edx

; 126  : 
; 127  :   assert( pack );
; 128  : 
; 129  :   if ( pack )

	cmp	esi, eax
	mov	DWORD PTR [edi+36], ebx
	mov	DWORD PTR [edi+40], edx
	je	$L15327

; 130  :   {
; 131  :     if ( flags & SPF_ROOT_TREE )

	mov	cl, BYTE PTR _flags$[ebp]
	mov	edx, 2
	test	cl, dl

; 132  :     {
; 133  :       pack->Init(this,pos,radius,userdata);

	mov	ecx, DWORD PTR _userdata$[ebp]
	mov	DWORD PTR [esi+28], eax
	mov	DWORD PTR [esi+64], ecx
	mov	ecx, DWORD PTR _pos$[ebp]
	fld	DWORD PTR _radius$[ebp]
	fmul	DWORD PTR _radius$[ebp]
	mov	DWORD PTR [esi+36], eax
	mov	DWORD PTR [esi+40], eax
	mov	DWORD PTR [esi+52], eax
	mov	DWORD PTR [esi+44], eax
	mov	DWORD PTR [esi+48], eax
	mov	DWORD PTR [esi+68], edi
	mov	ebx, DWORD PTR [ecx]
	mov	DWORD PTR [esi], ebx
	mov	ebx, DWORD PTR [ecx+4]
	mov	DWORD PTR [esi+4], ebx
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [esi+8], ecx
	mov	ecx, DWORD PTR _radius$[ebp]
	fstp	DWORD PTR [esi+16]
	mov	DWORD PTR [esi+12], ecx

; 134  :       pack->SetSpherePackFlag(SPF_ROOT_TREE); // member of the leaf node tree!

	mov	ebx, DWORD PTR [esi+52]
	je	SHORT $L12733
	or	ebx, edx

; 135  :       AddIntegrate(pack); // add to integration list.

	mov	cl, bl
	mov	DWORD PTR [esi+52], ebx
	test	cl, dl
	je	SHORT $L15190
	mov	ecx, DWORD PTR [edi+4]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR [ecx+32], esi
	mov	DWORD PTR [esi+36], edx
	mov	DWORD PTR [esi+40], eax
	cmp	edx, eax
	mov	DWORD PTR [esi+28], ecx
	je	SHORT $L15209
	jmp	SHORT $L15328
$L12733:

; 136  :     }
; 137  :     else
; 138  :     {
; 139  :       pack->Init(this,pos,radius,userdata);
; 140  :       pack->SetSpherePackFlag(SPF_LEAF_TREE); // member of the leaf node tree!

	or	ebx, 4

; 141  :       AddIntegrate(pack); // add to integration list.

	mov	cl, bl
	mov	DWORD PTR [esi+52], ebx
	test	cl, dl
	je	SHORT $L15190
	mov	ecx, DWORD PTR [edi+4]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR [ecx+32], esi
	mov	DWORD PTR [esi+36], edx
	mov	DWORD PTR [esi+40], eax
	cmp	edx, eax
	mov	DWORD PTR [esi+28], ecx
	je	SHORT $L15209
$L15328:
	mov	DWORD PTR [edx+40], esi

; 135  :       AddIntegrate(pack); // add to integration list.

$L15209:

; 141  :       AddIntegrate(pack); // add to integration list.

	mov	edx, DWORD PTR [ecx+56]
	push	esi
	inc	edx
	mov	DWORD PTR [ecx+56], edx
	call	?Distance2@?$Vector3d@M@@QBEMABV1@@Z	; Vector3d<float>::Distance2
	fstp	ST(0)
	jmp	SHORT $L15191

; 135  :       AddIntegrate(pack); // add to integration list.

$L15190:

; 141  :       AddIntegrate(pack); // add to integration list.

	mov	ecx, DWORD PTR [edi+8]
	push	esi
	call	?AddChild@SpherePack@@QAEXPAV1@@Z	; SpherePack::AddChild
$L15191:
	mov	ecx, DWORD PTR [esi+52]
	push	esi
	or	ecx, 32					; 00000020H
	mov	DWORD PTR [esi+52], ecx
	mov	ecx, DWORD PTR [edi+44]
	call	?Push@SpherePackFifo@@QAEPAPAVSpherePack@@PAV2@@Z ; SpherePackFifo::Push
	mov	DWORD PTR [esi+48], eax
$L15327:

; 142  :     }
; 143  :   }
; 144  : 
; 145  :   return pack;

	mov	eax, esi

; 141  :       AddIntegrate(pack); // add to integration list.

$L15323:
	pop	edi
	pop	esi
	pop	ebx

; 146  : }

	pop	ebp
	ret	16					; 00000010H
?AddSphere@SpherePackFactory@@QAEPAVSpherePack@@ABV?$Vector3d@M@@MPAXH@Z ENDP ; SpherePackFactory::AddSphere
_TEXT	ENDS
PUBLIC	?AddIntegrate@SpherePackFactory@@QAEXPAVSpherePack@@@Z ; SpherePackFactory::AddIntegrate
_TEXT	SEGMENT
_pack$ = 8
?AddIntegrate@SpherePackFactory@@QAEXPAVSpherePack@@@Z PROC NEAR ; SpherePackFactory::AddIntegrate

; 149  : {

	push	ebp
	mov	ebp, esp
	push	esi

; 150  : 
; 151  :   if ( pack->HasSpherePackFlag(SPF_ROOT_TREE) )

	mov	esi, DWORD PTR _pack$[ebp]
	push	edi
	mov	edi, ecx
	test	BYTE PTR [esi+52], 2
	je	SHORT $L12739

; 152  :     mRoot->AddChild(pack);

	mov	ecx, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [ecx+32]
	mov	DWORD PTR [ecx+32], esi
	test	eax, eax
	mov	DWORD PTR [esi+36], eax
	mov	DWORD PTR [esi+40], 0
	mov	DWORD PTR [esi+28], ecx
	je	SHORT $L15370

; 153  :   else

	jmp	SHORT $L15437
$L12739:

; 154  :     mLeaf->AddChild(pack);

	mov	ecx, DWORD PTR [edi+8]
	mov	eax, DWORD PTR [ecx+32]
	mov	DWORD PTR [ecx+32], esi
	test	eax, eax
	mov	DWORD PTR [esi+36], eax
	mov	DWORD PTR [esi+40], 0
	mov	DWORD PTR [esi+28], ecx
	je	SHORT $L15370
$L15437:
	mov	DWORD PTR [eax+40], esi

; 152  :     mRoot->AddChild(pack);

$L15370:

; 154  :     mLeaf->AddChild(pack);

	mov	edx, DWORD PTR [ecx+56]
	push	esi
	inc	edx
	mov	DWORD PTR [ecx+56], edx
	call	?Distance2@?$Vector3d@M@@QBEMABV1@@Z	; Vector3d<float>::Distance2

; 155  : 
; 156  :   pack->SetSpherePackFlag(SPF_INTEGRATE); // still needs to be integrated!

	mov	eax, DWORD PTR [esi+52]
	or	al, 32					; 00000020H
	mov	DWORD PTR [esi+52], eax

; 157  :   SpherePack **fifo = mIntegrate->Push(pack); // add it to the integration stack.

	mov	eax, DWORD PTR [edi+44]
	fstp	ST(0)
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [eax+16]
	mov	edi, DWORD PTR [eax]
	inc	edi
	lea	ecx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [ecx], esi
	mov	edx, DWORD PTR [eax+4]
	mov	edi, DWORD PTR [eax+12]
	inc	edx
	cmp	edx, edi
	mov	DWORD PTR [eax+4], edx
	jne	SHORT $L15436
	mov	DWORD PTR [eax+4], 0
$L15436:

; 158  :   pack->SetFifo2(fifo);

	mov	DWORD PTR [esi+48], ecx
	pop	edi
	pop	esi

; 159  : }

	pop	ebp
	ret	4
?AddIntegrate@SpherePackFactory@@QAEXPAVSpherePack@@@Z ENDP ; SpherePackFactory::AddIntegrate
_TEXT	ENDS
PUBLIC	?AddRecompute@SpherePackFactory@@QAEXPAVSpherePack@@@Z ; SpherePackFactory::AddRecompute
_TEXT	SEGMENT
_recompute$ = 8
?AddRecompute@SpherePackFactory@@QAEXPAVSpherePack@@@Z PROC NEAR ; SpherePackFactory::AddRecompute

; 162  : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi

; 163  :   if ( !recompute->HasSpherePackFlag(SPF_RECOMPUTE) )

	mov	esi, DWORD PTR _recompute$[ebp]
	push	edi
	mov	edi, ecx
	mov	eax, DWORD PTR [esi+52]
	test	al, 16					; 00000010H
	jne	$L15663

; 164  :   {
; 165  :     if ( recompute->GetChildCount() )

	mov	ecx, DWORD PTR [esi+56]
	xor	ebx, ebx
	cmp	ecx, ebx
	je	SHORT $L12747

; 166  :     {
; 167  :       recompute->SetSpherePackFlag(SPF_RECOMPUTE); // needs to be recalculated!

	or	al, 16					; 00000010H
	mov	DWORD PTR [esi+52], eax

; 168  :       SpherePack **fifo = mRecompute->Push(recompute);

	mov	eax, DWORD PTR [edi+48]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [eax+16]
	mov	edi, DWORD PTR [eax]
	inc	edi
	lea	ecx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [ecx], esi
	mov	edx, DWORD PTR [eax+4]
	mov	edi, DWORD PTR [eax+12]
	inc	edx
	cmp	edx, edi
	mov	DWORD PTR [eax+4], edx
	jne	SHORT $L15455
	mov	DWORD PTR [eax+4], ebx
$L15455:

; 169  :       recompute->SetFifo1(fifo);

	mov	DWORD PTR [esi+44], ecx
	pop	edi
	pop	esi
	pop	ebx

; 174  :     }
; 175  :   }
; 176  : }

	pop	ebp
	ret	4
$L12747:

; 170  :     }
; 171  :     else
; 172  :     {
; 173  :       Remove(recompute);

	test	al, 8
	jne	$L15663
	test	al, 1
	je	SHORT $L15694
	test	al, 4
	je	SHORT $L15694
	mov	eax, DWORD PTR [esi+64]
	mov	ecx, edi
	push	eax
	call	?Remove@SpherePackFactory@@QAEXPAVSpherePack@@@Z ; SpherePackFactory::Remove
$L15694:
	mov	eax, DWORD PTR [esi+44]
	cmp	eax, ebx
	je	SHORT $L15634
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [esi+44], ebx
$L15634:
	mov	eax, DWORD PTR [esi+48]
	cmp	eax, ebx
	je	SHORT $L15635
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [esi+48], ebx
$L15635:
	mov	edx, DWORD PTR [esi+28]
	cmp	edx, ebx
	je	SHORT $L15662
	mov	ecx, DWORD PTR [esi+40]
	mov	eax, DWORD PTR [esi+36]
	cmp	ecx, ebx
	je	SHORT $L15656
	cmp	eax, ebx
	mov	DWORD PTR [ecx+36], eax
	je	SHORT $L15649
	mov	DWORD PTR [eax+40], ecx
	jmp	SHORT $L15649
$L15656:
	cmp	eax, ebx
	mov	DWORD PTR [edx+32], eax
	je	SHORT $L15649
	mov	DWORD PTR [eax+40], ebx
$L15649:
	mov	eax, DWORD PTR [edx+56]
	dec	eax
	mov	DWORD PTR [edx+56], eax
	jne	SHORT $L15662
	test	BYTE PTR [edx+52], 1
	je	SHORT $L15662
	mov	ecx, DWORD PTR [edx+68]
	push	edx
	call	?Remove@SpherePackFactory@@QAEXPAVSpherePack@@@Z ; SpherePackFactory::Remove
$L15662:
	mov	DWORD PTR [esi+28], ebx
	mov	eax, DWORD PTR [edi+20]
	cmp	esi, eax
	jne	SHORT $L15664
	mov	ecx, DWORD PTR [esi+20]
	mov	DWORD PTR [edi+20], ecx
$L15664:
	mov	ecx, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [esi+20]
	cmp	ecx, ebx
	je	SHORT $L15666
	cmp	eax, ebx
	mov	DWORD PTR [ecx+20], eax
	je	SHORT $L15686
	mov	DWORD PTR [eax+24], ecx
	jmp	SHORT $L15686
$L15666:
	cmp	eax, ebx
	mov	DWORD PTR [edi+28], eax
	je	SHORT $L15686
	mov	DWORD PTR [eax+24], ebx
$L15686:
	mov	eax, DWORD PTR [edi+32]
	mov	DWORD PTR [edi+32], esi
	mov	DWORD PTR [esi+24], ebx
	mov	DWORD PTR [esi+20], eax
	mov	ecx, DWORD PTR [edi+36]
	mov	eax, DWORD PTR [edi+40]
	dec	ecx
	inc	eax
	mov	DWORD PTR [edi+36], ecx
	mov	DWORD PTR [edi+40], eax
$L15663:
	pop	edi
	pop	esi
	pop	ebx

; 174  :     }
; 175  :   }
; 176  : }

	pop	ebp
	ret	4
?AddRecompute@SpherePackFactory@@QAEXPAVSpherePack@@@Z ENDP ; SpherePackFactory::AddRecompute
_TEXT	ENDS
PUBLIC	?Render@SpherePack@@QAEXI@Z			; SpherePack::Render
PUBLIC	?Render@SpherePackFactory@@QAEXXZ		; SpherePackFactory::Render
EXTRN	?DrawLine@@YAHHHHHH@Z:NEAR			; DrawLine
EXTRN	?DrawCircle@@YAHHHHH@Z:NEAR			; DrawCircle
_TEXT	SEGMENT
?Render@SpherePackFactory@@QAEXXZ PROC NEAR		; SpherePackFactory::Render

; 179  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	mov	ebx, ecx
	push	esi
	push	edi

; 180  :   #if DEMO
; 181  :   mRoot->Render( mRoot->GetColor() );

	mov	esi, DWORD PTR [ebx+4]
	mov	eax, DWORD PTR [esi+52]
	mov	edi, DWORD PTR [esi+72]
	test	al, 8
	jne	$L15804
	test	al, 1
	je	SHORT $L15797
	jmp	SHORT $L15799
$L15797:
	mov	eax, DWORD PTR [esi+28]
	test	BYTE PTR [eax+52], 8
	je	SHORT $L15799
	mov	edi, 16777215				; 00ffffffH
$L15799:
	fld	DWORD PTR [esi+12]
	fistp	QWORD PTR -8+[ebp]
	mov	ecx, DWORD PTR -8+[ebp]
	push	edi
	push	ecx
	fld	DWORD PTR [esi+4]
	fistp	QWORD PTR -8+[ebp]
	mov	edx, DWORD PTR -8+[ebp]
	push	edx
	fld	DWORD PTR [esi]
	fistp	QWORD PTR -8+[ebp]
	mov	eax, DWORD PTR -8+[ebp]
	push	eax
	call	?DrawCircle@@YAHHHHH@Z			; DrawCircle
	mov	eax, DWORD PTR [esi+52]
	add	esp, 16					; 00000010H
	test	al, 1
	je	$L15804
	fld	DWORD PTR [esi+12]
	test	al, 4
	push	edi
	je	SHORT $L15801
	fistp	QWORD PTR -8+[ebp]
	mov	ecx, DWORD PTR -8+[ebp]
	push	ecx
	fld	DWORD PTR [esi+4]
	fistp	QWORD PTR -8+[ebp]
	mov	edx, DWORD PTR -8+[ebp]
	push	edx
	fld	DWORD PTR [esi]
	fistp	QWORD PTR -8+[ebp]
	mov	eax, DWORD PTR -8+[ebp]
	push	eax
	call	?DrawCircle@@YAHHHHH@Z			; DrawCircle
	mov	ecx, DWORD PTR [esi+64]
	add	esp, 16					; 00000010H
	mov	eax, DWORD PTR [ecx+28]
	test	eax, eax
	je	SHORT $L15804
	test	BYTE PTR [eax+52], 8
	jne	SHORT $L15804
	fld	DWORD PTR [eax+4]
	mov	edx, DWORD PTR [eax+72]
	fistp	QWORD PTR -8+[ebp]
	mov	ecx, DWORD PTR -8+[ebp]
	push	edx
	push	ecx
	fld	DWORD PTR [eax]
	fistp	QWORD PTR -8+[ebp]
	mov	edx, DWORD PTR -8+[ebp]
	push	edx
	fld	DWORD PTR [esi+4]
	fistp	QWORD PTR -8+[ebp]
	mov	eax, DWORD PTR -8+[ebp]
	push	eax
	fld	DWORD PTR [esi]
	fistp	QWORD PTR -8+[ebp]
	mov	ecx, DWORD PTR -8+[ebp]
	push	ecx
	call	?DrawLine@@YAHHHHHH@Z			; DrawLine
	add	esp, 20					; 00000014H
	jmp	SHORT $L15804
$L15801:
	fistp	QWORD PTR -8+[ebp]
	mov	edx, DWORD PTR -8+[ebp]
	add	edx, 3
	push	edx
	fld	DWORD PTR [esi+4]
	fistp	QWORD PTR -8+[ebp]
	mov	eax, DWORD PTR -8+[ebp]
	push	eax
	fld	DWORD PTR [esi]
	fistp	QWORD PTR -8+[ebp]
	mov	ecx, DWORD PTR -8+[ebp]
	push	ecx
	call	?DrawCircle@@YAHHHHH@Z			; DrawCircle
	add	esp, 16					; 00000010H
$L15804:
	mov	esi, DWORD PTR [esi+32]
	test	esi, esi
	je	SHORT $L15808
$L15807:
	push	edi
	mov	ecx, esi
	call	?Render@SpherePack@@QAEXI@Z		; SpherePack::Render
	mov	esi, DWORD PTR [esi+36]
	test	esi, esi
	jne	SHORT $L15807
$L15808:

; 182  :   mLeaf->Render( mLeaf->GetColor() );

	mov	esi, DWORD PTR [ebx+8]
	mov	eax, DWORD PTR [esi+52]
	mov	edi, DWORD PTR [esi+72]
	test	al, 8
	jne	$L15895
	test	al, 1
	je	SHORT $L15883
	jmp	SHORT $L15887
$L15883:
	mov	edx, DWORD PTR [esi+28]
	test	BYTE PTR [edx+52], 8
	je	SHORT $L15887
	mov	edi, 16777215				; 00ffffffH
$L15887:
	fld	DWORD PTR [esi+12]
	fistp	QWORD PTR -8+[ebp]
	mov	eax, DWORD PTR -8+[ebp]
	push	edi
	push	eax
	fld	DWORD PTR [esi+4]
	fistp	QWORD PTR -8+[ebp]
	mov	ecx, DWORD PTR -8+[ebp]
	push	ecx
	fld	DWORD PTR [esi]
	fistp	QWORD PTR -8+[ebp]
	mov	edx, DWORD PTR -8+[ebp]
	push	edx
	call	?DrawCircle@@YAHHHHH@Z			; DrawCircle
	mov	eax, DWORD PTR [esi+52]
	add	esp, 16					; 00000010H
	test	al, 1
	je	$L15895
	fld	DWORD PTR [esi+12]
	test	al, 4
	push	edi
	je	SHORT $L15889
	fistp	QWORD PTR -8+[ebp]
	mov	eax, DWORD PTR -8+[ebp]
	push	eax
	fld	DWORD PTR [esi+4]
	fistp	QWORD PTR -8+[ebp]
	mov	ecx, DWORD PTR -8+[ebp]
	push	ecx
	fld	DWORD PTR [esi]
	fistp	QWORD PTR -8+[ebp]
	mov	edx, DWORD PTR -8+[ebp]
	push	edx
	call	?DrawCircle@@YAHHHHH@Z			; DrawCircle
	mov	eax, DWORD PTR [esi+64]
	add	esp, 16					; 00000010H
	mov	eax, DWORD PTR [eax+28]
	test	eax, eax
	je	SHORT $L15895
	test	BYTE PTR [eax+52], 8
	jne	SHORT $L15895
	fld	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+72]
	fistp	QWORD PTR -8+[ebp]
	mov	edx, DWORD PTR -8+[ebp]
	push	ecx
	push	edx
	fld	DWORD PTR [eax]
	fistp	QWORD PTR -8+[ebp]
	mov	eax, DWORD PTR -8+[ebp]
	push	eax
	fld	DWORD PTR [esi+4]
	fistp	QWORD PTR -8+[ebp]
	mov	ecx, DWORD PTR -8+[ebp]
	push	ecx
	fld	DWORD PTR [esi]
	fistp	QWORD PTR -8+[ebp]
	mov	edx, DWORD PTR -8+[ebp]
	push	edx
	call	?DrawLine@@YAHHHHHH@Z			; DrawLine
	add	esp, 20					; 00000014H
	jmp	SHORT $L15895
$L15889:
	fistp	QWORD PTR -8+[ebp]
	mov	eax, DWORD PTR -8+[ebp]
	add	eax, 3
	push	eax
	fld	DWORD PTR [esi+4]
	fistp	QWORD PTR -8+[ebp]
	mov	ecx, DWORD PTR -8+[ebp]
	push	ecx
	fld	DWORD PTR [esi]
	fistp	QWORD PTR -8+[ebp]
	mov	edx, DWORD PTR -8+[ebp]
	push	edx
	call	?DrawCircle@@YAHHHHH@Z			; DrawCircle
	add	esp, 16					; 00000010H
$L15895:
	mov	esi, DWORD PTR [esi+32]
	test	esi, esi
	je	SHORT $L15902
$L15901:
	push	edi
	mov	ecx, esi
	call	?Render@SpherePack@@QAEXI@Z		; SpherePack::Render
	mov	esi, DWORD PTR [esi+36]
	test	esi, esi
	jne	SHORT $L15901
$L15902:
	pop	edi
	pop	esi
	pop	ebx

; 183  :   #endif
; 184  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Render@SpherePackFactory@@QAEXXZ ENDP			; SpherePackFactory::Render
_TEXT	ENDS
;	COMDAT ?Render@SpherePack@@QAEXI@Z
_TEXT	SEGMENT
_color$ = 8
?Render@SpherePack@@QAEXI@Z PROC NEAR			; SpherePack::Render, COMDAT

; 188  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	esi, ecx
	push	edi

; 189  :   #if DEMO
; 190  :   if ( !HasSpherePackFlag(SPF_ROOTNODE) )

	mov	eax, DWORD PTR [esi+52]
	test	al, 8
	jne	$L16000

; 191  :   {
; 192  : 
; 193  :     if ( HasSpherePackFlag(SPF_SUPERSPHERE) )

	test	al, 1
	je	SHORT $L12759

; 194  :     {
; 195  :       color = mColor;

	mov	edi, DWORD PTR [esi+72]

; 196  :     }
; 197  :     else

	jmp	SHORT $L12761
$L12759:

; 198  :     {
; 199  :       if ( mParent->HasSpherePackFlag(SPF_ROOTNODE) ) color = 0x00FFFFFF;

	mov	eax, DWORD PTR [esi+28]
	mov	edi, 16777215				; 00ffffffH
	test	BYTE PTR [eax+52], 8
	jne	SHORT $L12761
	mov	edi, DWORD PTR _color$[ebp]
$L12761:

; 200  :     }
; 201  :     #if DEMO
; 202  :   	DrawCircle( int(mCenter.x), int(mCenter.y),int(GetRadius()),color);

	fld	DWORD PTR [esi+12]
	fistp	QWORD PTR -8+[ebp]
	mov	ecx, DWORD PTR -8+[ebp]
	push	edi
	push	ecx
	fld	DWORD PTR [esi+4]
	fistp	QWORD PTR -8+[ebp]
	mov	edx, DWORD PTR -8+[ebp]
	push	edx
	fld	DWORD PTR [esi]
	fistp	QWORD PTR -8+[ebp]
	mov	eax, DWORD PTR -8+[ebp]
	push	eax
	call	?DrawCircle@@YAHHHHH@Z			; DrawCircle

; 203  :     #endif
; 204  :     if ( HasSpherePackFlag(SPF_SUPERSPHERE) )

	mov	eax, DWORD PTR [esi+52]
	add	esp, 16					; 00000010H
	test	al, 1
	je	$L12767

; 205  :     {
; 206  :       if ( HasSpherePackFlag(SPF_LEAF_TREE) )
; 207  :       {
; 208  : 
; 209  :         #if DEMO
; 210  :     	  DrawCircle( int(mCenter.x), int(mCenter.y),int(GetRadius()),color);

	fld	DWORD PTR [esi+12]
	test	al, 4
	push	edi
	je	SHORT $L12763
	fistp	QWORD PTR -8+[ebp]
	mov	ecx, DWORD PTR -8+[ebp]
	push	ecx
	fld	DWORD PTR [esi+4]
	fistp	QWORD PTR -8+[ebp]
	mov	edx, DWORD PTR -8+[ebp]
	push	edx
	fld	DWORD PTR [esi]
	fistp	QWORD PTR -8+[ebp]
	mov	eax, DWORD PTR -8+[ebp]
	push	eax
	call	?DrawCircle@@YAHHHHH@Z			; DrawCircle

; 211  :         #endif
; 212  :         SpherePack *link = (SpherePack *) GetUserData();
; 213  : 
; 214  :         link = link->GetParent();

	mov	ecx, DWORD PTR [esi+64]
	add	esp, 16					; 00000010H
	mov	eax, DWORD PTR [ecx+28]

; 215  : 
; 216  :         if ( link && !link->HasSpherePackFlag(SPF_ROOTNODE) )

	test	eax, eax
	je	SHORT $L12767
	test	BYTE PTR [eax+52], 8
	jne	SHORT $L12767

; 217  :         {
; 218  :           DrawLine( int(mCenter.x), int(mCenter.y),
; 219  :                     int(link->mCenter.x), int(link->mCenter.y),
; 220  :                     link->GetColor() );

	fld	DWORD PTR [eax+4]
	mov	edx, DWORD PTR [eax+72]
	fistp	QWORD PTR -8+[ebp]
	mov	ecx, DWORD PTR -8+[ebp]
	push	edx
	push	ecx
	fld	DWORD PTR [eax]
	fistp	QWORD PTR -8+[ebp]
	mov	edx, DWORD PTR -8+[ebp]
	push	edx
	fld	DWORD PTR [esi+4]
	fistp	QWORD PTR -8+[ebp]
	mov	eax, DWORD PTR -8+[ebp]
	push	eax
	fld	DWORD PTR [esi]
	fistp	QWORD PTR -8+[ebp]
	mov	ecx, DWORD PTR -8+[ebp]
	push	ecx
	call	?DrawLine@@YAHHHHHH@Z			; DrawLine
	add	esp, 20					; 00000014H

; 221  :         }
; 222  :       }
; 223  :       else

	jmp	SHORT $L12767
$L12763:

; 224  :       {
; 225  :         #if DEMO
; 226  :     	  DrawCircle( int(mCenter.x), int(mCenter.y),int(GetRadius())+3,color);

	fistp	QWORD PTR -8+[ebp]
	mov	edx, DWORD PTR -8+[ebp]
	add	edx, 3
	push	edx
	fld	DWORD PTR [esi+4]
	fistp	QWORD PTR -8+[ebp]
	mov	eax, DWORD PTR -8+[ebp]
	push	eax
	fld	DWORD PTR [esi]
	fistp	QWORD PTR -8+[ebp]
	mov	ecx, DWORD PTR -8+[ebp]
	push	ecx
	call	?DrawCircle@@YAHHHHH@Z			; DrawCircle
	add	esp, 16					; 00000010H
	jmp	SHORT $L12767
$L16000:
	mov	edi, DWORD PTR _color$[ebp]
$L12767:

; 227  :         #endif
; 228  :       }
; 229  : 
; 230  :     }
; 231  : 
; 232  :   }
; 233  : 
; 234  :   if ( mChildren )

	mov	esi, DWORD PTR [esi+32]
	test	esi, esi
	je	SHORT $L12772
$L12771:

; 235  :   {
; 236  :     SpherePack *pack = mChildren;
; 237  : 
; 238  :     while ( pack )
; 239  :     {
; 240  :       pack->Render(color);

	push	edi
	mov	ecx, esi
	call	?Render@SpherePack@@QAEXI@Z		; SpherePack::Render

; 241  :       pack = pack->GetNextSibling();

	mov	esi, DWORD PTR [esi+36]
	test	esi, esi
	jne	SHORT $L12771
$L12772:
	pop	edi
	pop	esi

; 242  :     }
; 243  :   }
; 244  :   #endif
; 245  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Render@SpherePack@@QAEXI@Z ENDP			; SpherePack::Render
_TEXT	ENDS
_TEXT	SEGMENT
_pack$ = 8
?Remove@SpherePackFactory@@QAEXPAVSpherePack@@@Z PROC NEAR ; SpherePackFactory::Remove

; 364  : {

	push	ebp
	mov	ebp, esp
	push	esi

; 365  : 
; 366  :   if ( pack->HasSpherePackFlag(SPF_ROOTNODE) ) return; // CAN NEVER REMOVE THE ROOT NODE EVER!!!

	mov	esi, DWORD PTR _pack$[ebp]
	push	edi
	mov	edi, ecx
	mov	eax, DWORD PTR [esi+52]
	test	al, 8
	jne	$L16134

; 367  : 
; 368  :   if ( pack->HasSpherePackFlag(SPF_SUPERSPHERE) && pack->HasSpherePackFlag(SPF_LEAF_TREE) )

	test	al, 1
	je	SHORT $L12819
	test	al, 4
	je	SHORT $L12819

; 369  :   {
; 370  : 
; 371  :     SpherePack *link = (SpherePack *) pack->GetUserData();
; 372  : 
; 373  :     Remove(link);

	mov	eax, DWORD PTR [esi+64]
	push	eax
	call	?Remove@SpherePackFactory@@QAEXPAVSpherePack@@@Z ; SpherePackFactory::Remove
$L12819:

; 374  :   }
; 375  : 
; 376  :   pack->Unlink();

	mov	eax, DWORD PTR [esi+44]
	push	ebx
	xor	ebx, ebx
	cmp	eax, ebx
	je	SHORT $L16075
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [esi+44], ebx
$L16075:
	mov	eax, DWORD PTR [esi+48]
	cmp	eax, ebx
	je	SHORT $L16076
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [esi+48], ebx
$L16076:
	mov	edx, DWORD PTR [esi+28]
	cmp	edx, ebx
	je	SHORT $L16087
	mov	ecx, DWORD PTR [esi+40]
	mov	eax, DWORD PTR [esi+36]
	cmp	ecx, ebx
	je	SHORT $L16081
	cmp	eax, ebx
	mov	DWORD PTR [ecx+36], eax
	je	SHORT $L16099
	mov	DWORD PTR [eax+40], ecx
	jmp	SHORT $L16099
$L16081:
	cmp	eax, ebx
	mov	DWORD PTR [edx+32], eax
	je	SHORT $L16099
	mov	DWORD PTR [eax+40], ebx
$L16099:
	mov	eax, DWORD PTR [edx+56]
	dec	eax
	mov	DWORD PTR [edx+56], eax
	jne	SHORT $L16087
	test	BYTE PTR [edx+52], 1
	je	SHORT $L16087
	mov	ecx, DWORD PTR [edx+68]
	push	edx
	call	?Remove@SpherePackFactory@@QAEXPAVSpherePack@@@Z ; SpherePackFactory::Remove
$L16087:
	mov	DWORD PTR [esi+28], ebx

; 377  : 
; 378  :   mSpheres.Release(pack);

	mov	eax, DWORD PTR [edi+20]
	cmp	esi, eax
	jne	SHORT $L16135
	mov	ecx, DWORD PTR [esi+20]
	mov	DWORD PTR [edi+20], ecx
$L16135:
	mov	ecx, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [esi+20]
	cmp	ecx, ebx
	je	SHORT $L16137
	cmp	eax, ebx
	mov	DWORD PTR [ecx+20], eax
	je	SHORT $L16157
	mov	DWORD PTR [eax+24], ecx
	jmp	SHORT $L16157
$L16137:
	cmp	eax, ebx
	mov	DWORD PTR [edi+28], eax
	je	SHORT $L16157
	mov	DWORD PTR [eax+24], ebx
$L16157:
	mov	eax, DWORD PTR [edi+32]
	mov	DWORD PTR [edi+32], esi
	mov	DWORD PTR [esi+24], ebx
	mov	DWORD PTR [esi+20], eax
	mov	ecx, DWORD PTR [edi+36]
	mov	eax, DWORD PTR [edi+40]
	dec	ecx
	inc	eax
	mov	DWORD PTR [edi+36], ecx
	mov	DWORD PTR [edi+40], eax
	pop	ebx
$L16134:
	pop	edi
	pop	esi

; 379  : }

	pop	ebp
	ret	4
?Remove@SpherePackFactory@@QAEXPAVSpherePack@@@Z ENDP	; SpherePackFactory::Remove
_TEXT	ENDS
PUBLIC	?GetColor@SpherePackFactory@@QAEIXZ		; SpherePackFactory::GetColor
_TEXT	SEGMENT
?GetColor@SpherePackFactory@@QAEIXZ PROC NEAR		; SpherePackFactory::GetColor

; 384  :   unsigned int ret = mColors[mColorCount];

	mov	edx, DWORD PTR [ecx+52]
	mov	eax, DWORD PTR [ecx+edx*4+56]

; 385  :   mColorCount++;

	inc	edx

; 386  :   if ( mColorCount == MAXCOLORS ) mColorCount = 0;

	cmp	edx, 12					; 0000000cH
	mov	DWORD PTR [ecx+52], edx
	jne	SHORT $L12827
	mov	DWORD PTR [ecx+52], 0
$L12827:

; 387  :   return ret;
; 388  : }

	ret	0
?GetColor@SpherePackFactory@@QAEIXZ ENDP		; SpherePackFactory::GetColor
_TEXT	ENDS
PUBLIC	?NewPosRadius@SpherePack@@QAEXABV?$Vector3d@M@@M@Z ; SpherePack::NewPosRadius
PUBLIC	?LostChild@SpherePack@@QAEXPAV1@@Z		; SpherePack::LostChild
PUBLIC	?Recompute@SpherePack@@QAE_NM@Z			; SpherePack::Recompute
PUBLIC	?GetFreeLink@?$Pool@VSpherePack@@@@QAEPAVSpherePack@@XZ ; Pool<SpherePack>::GetFreeLink
PUBLIC	__real@4@00000000000000000000
PUBLIC	??0?$Vector3d@M@@QAE@MMM@Z			; Vector3d<float>::Vector3d<float>
;	COMDAT __real@4@00000000000000000000
; File C:\WINDOWS\Desktop\Gems2 CD\SourceCode\04 Geometry Management\03 Ratcliff\spherepack.h
CONST	SEGMENT
__real@4@00000000000000000000 DD 000000000r	; 0
CONST	ENDS
_TEXT	SEGMENT
_total$16556 = -28
_count$16557 = 12
_oldpos$16563 = -40
_maxradius$16564 = 12
$T16573 = 8
$T16622 = 12
_pack$ = 8
_supersphere$ = 12
_node_size$ = 16
_this$ = -8
_neardist1$ = -12
_nearest2$ = -4
_neardist2$ = -16
_dist$12844 = 8
_newsize$12861 = 8
_total$16324 = -28
_count$16325 = 12
_oldpos$16331 = -40
_maxradius$16332 = 12
$T16366 = 8
$T16378 = 12
?Integrate@SpherePackFactory@@QAEXPAVSpherePack@@0M@Z PROC NEAR ; SpherePackFactory::Integrate

; 394  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H

; 395  :   // ok..time to integrate this sphere with the tree
; 396  :   // first find which supersphere we are closest to the center of
; 397  : 
; 398  :   SpherePack *search = supersphere->GetChildren();

	mov	eax, DWORD PTR _supersphere$[ebp]
	push	ebx
	push	esi

; 399  : 
; 400  :   SpherePack *nearest1 = 0;  // nearest supersphere we are completely

	xor	edx, edx
	mov	ebx, DWORD PTR [eax+32]
	xor	esi, esi
	push	edi

; 401  :   float neardist1 = 1e9;     // enclosed within
; 402  : 
; 403  :   SpherePack *nearest2 = 0; // supersphere we must grow the least to
; 404  :   float neardist2 = 1e9;    // add ourselves to.
; 405  : 
; 406  :   int scount = 1;
; 407  : 
; 408  :   while ( search )

	mov	edi, DWORD PTR _pack$[ebp]
	cmp	ebx, edx
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR _neardist1$[ebp], 1315859240	; 4e6e6b28H
	mov	DWORD PTR _nearest2$[ebp], edx
	mov	DWORD PTR _neardist2$[ebp], 1315859240	; 4e6e6b28H
	je	$L16648
$L12841:

; 409  :   {
; 410  :     if ( search->HasSpherePackFlag(SPF_SUPERSPHERE) && !search->HasSpherePackFlag(SPF_ROOTNODE) && search->GetChildCount() )

	mov	eax, DWORD PTR [ebx+52]
	test	al, 1
	je	SHORT $L12853
	test	al, 8
	jne	SHORT $L12853
	cmp	DWORD PTR [ebx+56], edx
	je	SHORT $L12853

; 411  :     {
; 412  : 
; 413  :       float dist = pack->DistanceSquared(search);

	push	ebx
	mov	ecx, edi
	call	?Distance2@?$Vector3d@M@@QBEMABV1@@Z	; Vector3d<float>::Distance2
	fstp	DWORD PTR _dist$12844[ebp]

; 414  : 
; 415  :       if ( nearest1 )

	test	esi, esi
	je	SHORT $L12845

; 416  :       {
; 417  :         if ( dist < neardist1 )

	fld	DWORD PTR _dist$12844[ebp]
	fcomp	DWORD PTR _neardist1$[ebp]
	fnstsw	ax
	test	ah, 1
	je	SHORT $L12853

; 418  :         {
; 419  : 
; 420  :           float d = sqrtf(dist)+pack->GetRadius();
; 421  : 
; 422  :           if ( d <= search->GetRadius() )

	fld	DWORD PTR _dist$12844[ebp]
	fsqrt
	fadd	DWORD PTR [edi+12]
	fld	DWORD PTR [ebx+12]
	fcompp
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L12853

; 423  :           {
; 424  :             neardist1 = dist;

	mov	ecx, DWORD PTR _dist$12844[ebp]

; 425  :             nearest1  = search;

	mov	esi, ebx
	mov	DWORD PTR _neardist1$[ebp], ecx

; 426  :           }
; 427  :         }
; 428  :       }
; 429  :       else

	jmp	SHORT $L12853
$L12845:

; 430  :       {
; 431  : 
; 432  :         float d = (sqrtf(dist) + pack->GetRadius())-search->GetRadius();

	fld	DWORD PTR _dist$12844[ebp]
	fsqrt
	fadd	DWORD PTR [edi+12]
	fsub	DWORD PTR [ebx+12]

; 433  : 
; 434  :         if ( d < neardist2 )

	fcom	DWORD PTR _neardist2$[ebp]
	fnstsw	ax
	test	ah, 1
	je	SHORT $L16660

; 435  :         {
; 436  :           if ( d < 0 )

	fcom	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L12852

; 437  :           {
; 438  :             neardist1 = dist;

	mov	edx, DWORD PTR _dist$12844[ebp]

; 439  :             nearest1  = search;

	mov	esi, ebx
	fstp	ST(0)
	mov	DWORD PTR _neardist1$[ebp], edx

; 440  :           }
; 441  :           else

	jmp	SHORT $L12853
$L12852:

; 442  :           {
; 443  :             neardist2 = d;

	fstp	DWORD PTR _neardist2$[ebp]

; 444  :             nearest2  = search;

	mov	DWORD PTR _nearest2$[ebp], ebx
	jmp	SHORT $L12853
$L16660:

; 433  : 
; 434  :         if ( d < neardist2 )

	fstp	ST(0)
$L12853:

; 445  :           }
; 446  :         }
; 447  :       }
; 448  :     }
; 449  :     search = search->GetNextSibling();

	mov	ebx, DWORD PTR [ebx+36]
	xor	edx, edx
	cmp	ebx, edx
	jne	$L12841

; 450  :   }
; 451  : 
; 452  :   // ok...now..on exit let's see what we got.
; 453  :   if ( nearest1 )

	cmp	esi, edx
	je	$L12854

; 454  :   {
; 455  :     // if we are inside an existing supersphere, we are all good!
; 456  :     // we need to detach item from wherever it is, and then add it to
; 457  :     // this supersphere as a child.
; 458  :     pack->Unlink();

	mov	eax, DWORD PTR [edi+44]
	cmp	eax, edx
	je	SHORT $L16218
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [edi+44], edx
$L16218:
	mov	eax, DWORD PTR [edi+48]
	cmp	eax, edx
	je	SHORT $L16219
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [edi+48], edx
$L16219:
	mov	ecx, DWORD PTR [edi+28]
	cmp	ecx, edx
	je	SHORT $L16220
	push	edi
	call	?LostChild@SpherePack@@QAEXPAV1@@Z	; SpherePack::LostChild
$L16220:
	xor	ecx, ecx
	mov	DWORD PTR [edi+28], ecx

; 459  :     nearest1->AddChild(pack);

	mov	eax, DWORD PTR [esi+32]
	mov	DWORD PTR [esi+32], edi
	cmp	eax, ecx
	mov	DWORD PTR [edi+36], eax
	mov	DWORD PTR [edi+40], ecx
	mov	DWORD PTR [edi+28], esi
	je	SHORT $L16257
	mov	DWORD PTR [eax+40], edi
$L16257:
	mov	ecx, DWORD PTR [esi+56]
	push	edi
	inc	ecx
	mov	DWORD PTR [esi+56], ecx
	mov	ecx, esi
	call	?Distance2@?$Vector3d@M@@QBEMABV1@@Z	; Vector3d<float>::Distance2
	fstp	ST(0)

; 460  :     pack->ComputeBindingDistance(nearest1);

	fld	DWORD PTR [esi+12]
	fsub	DWORD PTR [edi+12]
	fcom	DWORD PTR __real@4@00000000000000000000
	fst	DWORD PTR [edi+60]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L16275
	fstp	ST(0)
	mov	DWORD PTR [edi+60], 0
	jmp	SHORT $L16276
$L16275:
	fld	ST(0)
	fmul	ST(0), ST(1)
	fstp	DWORD PTR [edi+60]
	fstp	ST(0)
$L16276:

; 461  :     nearest1->Recompute(mSuperSphereGravy);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+112]
	mov	eax, DWORD PTR [esi+32]
	test	eax, eax
	mov	DWORD PTR $T16366[ebp], ecx
	je	$L16364
	test	BYTE PTR [esi+52], 8
	jne	$L16364
	push	0
	push	0
	push	0
	lea	ecx, DWORD PTR _total$16324[ebp]
	call	??0?$Vector3d@M@@QAE@MMM@Z		; Vector3d<float>::Vector3d<float>
	mov	ebx, DWORD PTR [esi+32]
	mov	DWORD PTR _count$16325[ebp], 0
	test	ebx, ebx
	je	$L16340
$L16327:
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	push	ebx
	call	??0?$Vector3d@M@@QAE@ABV0@@Z		; Vector3d<float>::Vector3d<float>
	lea	ecx, DWORD PTR _total$16324[ebp]
	call	??Y?$Vector3d@M@@QAEXV0@@Z		; Vector3d<float>::operator+=
	mov	ecx, DWORD PTR _count$16325[ebp]
	mov	ebx, DWORD PTR [ebx+36]
	inc	ecx
	test	ebx, ebx
	mov	DWORD PTR _count$16325[ebp], ecx
	jne	SHORT $L16327
	mov	eax, ecx
	test	eax, eax
	je	$L16340
	fild	DWORD PTR _count$16325[ebp]
	push	ecx
	lea	ecx, DWORD PTR _total$16324[ebp]
	fdivr	DWORD PTR __real@4@3fff8000000000000000
	fstp	DWORD PTR [esp]
	call	??X?$Vector3d@M@@QAEXM@Z		; Vector3d<float>::operator*=
	push	esi
	lea	ecx, DWORD PTR _oldpos$16331[ebp]
	call	??0?$Vector3d@M@@QAE@ABV0@@Z		; Vector3d<float>::Vector3d<float>
	lea	edx, DWORD PTR _total$16324[ebp]
	mov	ecx, esi
	push	edx
	call	??4?$Vector3d@M@@QAEAAV0@ABV0@@Z	; Vector3d<float>::operator=
	mov	DWORD PTR _maxradius$16332[ebp], ebx
	mov	ebx, DWORD PTR [esi+32]
	test	ebx, ebx
	je	SHORT $L16334
$L16333:
	push	ebx
	mov	ecx, esi
	call	?Distance2@?$Vector3d@M@@QBEMABV1@@Z	; Vector3d<float>::Distance2
	fsqrt
	fadd	DWORD PTR [ebx+12]
	fcom	DWORD PTR _maxradius$16332[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L16656
	fst	DWORD PTR _maxradius$16332[ebp]
	fadd	DWORD PTR $T16366[ebp]
	fld	DWORD PTR [esi+12]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$L16639
	jmp	SHORT $L16338
$L16656:
	fstp	ST(0)
$L16338:
	mov	ebx, DWORD PTR [ebx+36]
	test	ebx, ebx
	jne	SHORT $L16333
$L16334:
	fld	DWORD PTR _maxradius$16332[ebp]
	fadd	DWORD PTR $T16366[ebp]
	fst	DWORD PTR [esi+12]
	fld	ST(0)
	fmul	ST(0), ST(1)
	fstp	DWORD PTR [esi+16]
	mov	ebx, DWORD PTR [esi+32]
	test	ebx, ebx
	fstp	ST(0)
	je	SHORT $L16340
$L16339:
	push	esi
	mov	ecx, ebx
	call	?ComputeBindingDistance@SpherePack@@QAEXPAV1@@Z ; SpherePack::ComputeBindingDistance
	mov	ebx, DWORD PTR [ebx+36]
	test	ebx, ebx
	jne	SHORT $L16339
$L16340:
	mov	eax, DWORD PTR [esi+52]
	and	al, -17					; ffffffefH
	mov	DWORD PTR [esi+52], eax
$L16364:

; 462  : 
; 463  :     if ( nearest1->HasSpherePackFlag(SPF_LEAF_TREE) )

	test	BYTE PTR [esi+52], 4
	je	$L16627

; 464  :     {
; 465  :       SpherePack *link = (SpherePack *) nearest1->GetUserData();
; 466  :       link->NewPosRadius( nearest1->GetPos(), nearest1->GetRadius() );

	mov	ecx, DWORD PTR [esi+12]
	mov	ebx, DWORD PTR [esi+64]
	mov	DWORD PTR $T16378[ebp], ecx
	push	esi
	mov	ecx, ebx
	call	??4?$Vector3d@M@@QAEAAV0@ABV0@@Z	; Vector3d<float>::operator=
	mov	ecx, DWORD PTR [ebx+28]
	test	ecx, ecx
	je	$L16627
	test	BYTE PTR [ebx+52], 32			; 00000020H
	jne	$L16627
	fld	DWORD PTR [ebx+12]
	fcomp	DWORD PTR $T16378[ebp]
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L16426
	fld	DWORD PTR $T16378[ebp]
	fmul	DWORD PTR $T16378[ebp]
	mov	edx, DWORD PTR $T16378[ebp]
	push	ecx
	mov	ecx, ebx
	mov	DWORD PTR [ebx+12], edx
	fstp	DWORD PTR [ebx+16]
	call	?ComputeBindingDistance@SpherePack@@QAEXPAV1@@Z ; SpherePack::ComputeBindingDistance
$L16426:
	mov	eax, DWORD PTR [ebx+28]
	mov	ecx, ebx
	push	eax
	call	?Distance2@?$Vector3d@M@@QBEMABV1@@Z	; Vector3d<float>::Distance2
	fcomp	DWORD PTR [ebx+60]
	fnstsw	ax
	test	ah, 1
	mov	eax, DWORD PTR [ebx+28]
	mov	cl, BYTE PTR [eax+52]
	jne	SHORT $L16428
	test	cl, 16					; 00000010H
	jne	SHORT $L16429
	mov	ecx, DWORD PTR [ebx+68]
	push	eax
	call	?AddRecompute@SpherePackFactory@@QAEXPAVSpherePack@@@Z ; SpherePackFactory::AddRecompute
$L16429:
	mov	ecx, ebx
	call	?Unlink@SpherePack@@QAEXXZ		; SpherePack::Unlink
	mov	ecx, DWORD PTR [ebx+68]
	push	ebx
	call	?AddIntegrate@SpherePackFactory@@QAEXPAVSpherePack@@@Z ; SpherePackFactory::AddIntegrate

; 530  :       }
; 531  : 
; 532  :     }
; 533  :   }
; 534  : 
; 535  :   pack->ClearSpherePackFlag(SPF_INTEGRATE); // we've been integrated!

	mov	eax, DWORD PTR [edi+52]
	and	al, -33					; ffffffdfH
	mov	DWORD PTR [edi+52], eax

; 536  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$L16639:

; 461  :     nearest1->Recompute(mSuperSphereGravy);

	lea	eax, DWORD PTR _oldpos$16331[ebp]
	mov	ecx, esi
	push	eax
	call	??4?$Vector3d@M@@QAEAAV0@ABV0@@Z	; Vector3d<float>::operator=
	jmp	$L16340

; 464  :     {
; 465  :       SpherePack *link = (SpherePack *) nearest1->GetUserData();
; 466  :       link->NewPosRadius( nearest1->GetPos(), nearest1->GetRadius() );

$L16428:
	test	cl, 16					; 00000010H
	jne	$L16627
	mov	ecx, DWORD PTR [ebx+68]
	push	eax
	call	?AddRecompute@SpherePackFactory@@QAEXPAVSpherePack@@@Z ; SpherePackFactory::AddRecompute

; 530  :       }
; 531  : 
; 532  :     }
; 533  :   }
; 534  : 
; 535  :   pack->ClearSpherePackFlag(SPF_INTEGRATE); // we've been integrated!

	mov	eax, DWORD PTR [edi+52]
	and	al, -33					; ffffffdfH
	mov	DWORD PTR [edi+52], eax

; 536  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$L12854:

; 467  :     }
; 468  : 
; 469  :   }
; 470  :   else
; 471  :   {
; 472  :     bool newsphere = true;
; 473  : 
; 474  :     if ( nearest2 )

	mov	eax, DWORD PTR _nearest2$[ebp]
	cmp	eax, edx
	je	$L16648

; 475  :     {
; 476  :       float newsize = neardist2 + nearest2->GetRadius() + mSuperSphereGravy;

	fld	DWORD PTR [eax+12]

; 530  :       }
; 531  : 
; 532  :     }
; 533  :   }
; 534  : 
; 535  :   pack->ClearSpherePackFlag(SPF_INTEGRATE); // we've been integrated!

	mov	eax, DWORD PTR _this$[ebp]
	fadd	DWORD PTR [eax+112]
	fadd	DWORD PTR _neardist2$[ebp]
	fst	DWORD PTR _newsize$12861[ebp]
	fcomp	DWORD PTR _node_size$[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	$L16648
	mov	eax, DWORD PTR [edi+44]
	cmp	eax, edx
	je	SHORT $L16440
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [edi+44], edx
$L16440:
	mov	eax, DWORD PTR [edi+48]
	cmp	eax, edx
	je	SHORT $L16441
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [edi+48], edx
$L16441:
	mov	ecx, DWORD PTR [edi+28]
	cmp	ecx, edx
	je	SHORT $L16442
	push	edi
	call	?LostChild@SpherePack@@QAEXPAV1@@Z	; SpherePack::LostChild
$L16442:
	fld	DWORD PTR _newsize$12861[ebp]
	fmul	DWORD PTR _newsize$12861[ebp]
	mov	ecx, DWORD PTR _nearest2$[ebp]
	mov	eax, DWORD PTR _newsize$12861[ebp]
	xor	edx, edx
	mov	DWORD PTR [edi+28], edx
	mov	DWORD PTR [ecx+12], eax
	fstp	DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [ecx+32]
	mov	DWORD PTR [ecx+32], edi
	cmp	eax, edx
	mov	DWORD PTR [edi+36], eax
	mov	DWORD PTR [edi+40], edx
	mov	DWORD PTR [edi+28], ecx
	je	SHORT $L16477

; 477  : 
; 478  :       if ( newsize <= node_size )
; 479  :       {
; 480  :         pack->Unlink();
; 481  : 
; 482  :         nearest2->SetRadius(newsize);
; 483  :         nearest2->AddChild(pack);

	mov	DWORD PTR [eax+40], edi
$L16477:
	mov	esi, DWORD PTR [ecx+56]
	push	edi
	inc	esi
	mov	DWORD PTR [ecx+56], esi
	call	?Distance2@?$Vector3d@M@@QBEMABV1@@Z	; Vector3d<float>::Distance2

; 484  :         nearest2->Recompute(mSuperSphereGravy);

	mov	esi, DWORD PTR _nearest2$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	ST(0)
	mov	eax, DWORD PTR [esi+32]
	mov	edx, DWORD PTR [ecx+112]
	test	eax, eax
	mov	DWORD PTR $T16573[ebp], edx
	je	$L16551
	test	BYTE PTR [esi+52], 8
	jne	$L16551
	push	0
	push	0
	push	0
	lea	ecx, DWORD PTR _total$16556[ebp]
	call	??0?$Vector3d@M@@QAE@MMM@Z		; Vector3d<float>::Vector3d<float>
	mov	ebx, DWORD PTR [esi+32]
	mov	DWORD PTR _count$16557[ebp], 0
	test	ebx, ebx
	je	$L16572
$L16559:
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	push	ebx
	call	??0?$Vector3d@M@@QAE@ABV0@@Z		; Vector3d<float>::Vector3d<float>
	lea	ecx, DWORD PTR _total$16556[ebp]
	call	??Y?$Vector3d@M@@QAEXV0@@Z		; Vector3d<float>::operator+=
	mov	ecx, DWORD PTR _count$16557[ebp]
	mov	ebx, DWORD PTR [ebx+36]
	inc	ecx
	test	ebx, ebx
	mov	DWORD PTR _count$16557[ebp], ecx
	jne	SHORT $L16559
	mov	eax, ecx
	test	eax, eax
	je	$L16572
	fild	DWORD PTR _count$16557[ebp]
	push	ecx
	lea	ecx, DWORD PTR _total$16556[ebp]
	fdivr	DWORD PTR __real@4@3fff8000000000000000
	fstp	DWORD PTR [esp]
	call	??X?$Vector3d@M@@QAEXM@Z		; Vector3d<float>::operator*=
	push	esi
	lea	ecx, DWORD PTR _oldpos$16563[ebp]
	call	??0?$Vector3d@M@@QAE@ABV0@@Z		; Vector3d<float>::Vector3d<float>
	lea	eax, DWORD PTR _total$16556[ebp]
	mov	ecx, esi
	push	eax
	call	??4?$Vector3d@M@@QAEAAV0@ABV0@@Z	; Vector3d<float>::operator=
	mov	DWORD PTR _maxradius$16564[ebp], ebx
	mov	ebx, DWORD PTR [esi+32]
	test	ebx, ebx
	je	SHORT $L16566
$L16565:
	push	ebx
	mov	ecx, esi
	call	?Distance2@?$Vector3d@M@@QBEMABV1@@Z	; Vector3d<float>::Distance2
	fsqrt
	fadd	DWORD PTR [ebx+12]
	fcom	DWORD PTR _maxradius$16564[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L16658
	fst	DWORD PTR _maxradius$16564[ebp]
	fadd	DWORD PTR $T16573[ebp]
	fld	DWORD PTR [esi+12]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L16640
	jmp	SHORT $L16570
$L16658:
	fstp	ST(0)
$L16570:
	mov	ebx, DWORD PTR [ebx+36]
	test	ebx, ebx
	jne	SHORT $L16565
$L16566:
	fld	DWORD PTR _maxradius$16564[ebp]
	fadd	DWORD PTR $T16573[ebp]
	fst	DWORD PTR [esi+12]
	fld	ST(0)
	fmul	ST(0), ST(1)
	fstp	DWORD PTR [esi+16]
	mov	ebx, DWORD PTR [esi+32]
	test	ebx, ebx
	fstp	ST(0)
	je	SHORT $L16572
$L16571:
	push	esi
	mov	ecx, ebx
	call	?ComputeBindingDistance@SpherePack@@QAEXPAV1@@Z ; SpherePack::ComputeBindingDistance
	mov	ebx, DWORD PTR [ebx+36]
	test	ebx, ebx
	jne	SHORT $L16571
$L16572:
	mov	eax, DWORD PTR [esi+52]
	and	al, -17					; ffffffefH
	mov	DWORD PTR [esi+52], eax
$L16551:

; 485  :         pack->ComputeBindingDistance(nearest2);

	push	esi
	mov	ecx, edi
	call	?ComputeBindingDistance@SpherePack@@QAEXPAV1@@Z ; SpherePack::ComputeBindingDistance

; 486  : 
; 487  :         if ( nearest2->HasSpherePackFlag(SPF_LEAF_TREE) )

	test	BYTE PTR [esi+52], 4
	je	$L16627

; 488  :         {
; 489  :           SpherePack *link = (SpherePack *) nearest2->GetUserData();
; 490  :           link->NewPosRadius( nearest2->GetPos(), nearest2->GetRadius() );

	fld	DWORD PTR [esi+12]
	push	ecx
	mov	ecx, DWORD PTR [esi+64]
	fstp	DWORD PTR [esp]
	push	esi
	call	?NewPosRadius@SpherePack@@QAEXABV?$Vector3d@M@@M@Z ; SpherePack::NewPosRadius

; 530  :       }
; 531  : 
; 532  :     }
; 533  :   }
; 534  : 
; 535  :   pack->ClearSpherePackFlag(SPF_INTEGRATE); // we've been integrated!

	mov	eax, DWORD PTR [edi+52]
	and	al, -33					; ffffffdfH
	mov	DWORD PTR [edi+52], eax

; 536  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$L16640:

; 484  :         nearest2->Recompute(mSuperSphereGravy);

	lea	ecx, DWORD PTR _oldpos$16563[ebp]
	push	ecx
	mov	ecx, esi
	call	??4?$Vector3d@M@@QAEAAV0@ABV0@@Z	; Vector3d<float>::operator=
	jmp	SHORT $L16572
$L16648:

; 491  :         }
; 492  : 
; 493  :         newsphere = false;
; 494  : 
; 495  :       }
; 496  : 
; 497  :     }
; 498  : 
; 499  :     if ( newsphere )
; 500  :     {
; 501  :       assert( supersphere->HasSpherePackFlag(SPF_ROOTNODE) );
; 502  :       // we are going to create a new superesphere around this guy!
; 503  :       pack->Unlink();

	mov	ecx, edi
	call	?Unlink@SpherePack@@QAEXXZ		; SpherePack::Unlink

; 504  : 
; 505  :       SpherePack *parent = mSpheres.GetFreeLink();

	mov	ebx, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [ebx+16]
	call	?GetFreeLink@?$Pool@VSpherePack@@@@QAEPAVSpherePack@@XZ ; Pool<SpherePack>::GetFreeLink

; 506  :       assert( parent );
; 507  :       parent->Init( this, pack->GetPos(), pack->GetRadius()+mSuperSphereGravy, 0 );

	fld	DWORD PTR [edi+12]
	fadd	DWORD PTR [ebx+112]
	push	0
	push	ecx
	mov	esi, eax
	mov	ecx, esi
	fstp	DWORD PTR [esp]
	push	edi
	push	ebx
	call	?Init@SpherePack@@QAEXPAVSpherePackFactory@@ABV?$Vector3d@M@@MPAX@Z ; SpherePack::Init

; 508  : 
; 509  :       if ( supersphere->HasSpherePackFlag(SPF_ROOT_TREE) )

	mov	edx, DWORD PTR _supersphere$[ebp]
	test	BYTE PTR [edx+52], 2

; 510  :         parent->SetSpherePackFlag(SPF_ROOT_TREE);

	mov	eax, DWORD PTR [esi+52]
	je	SHORT $L12870
	or	al, 2

; 511  :       else

	jmp	SHORT $L16661
$L12870:

; 512  :         parent->SetSpherePackFlag(SPF_LEAF_TREE);

	or	al, 4
$L16661:

; 513  : 
; 514  :       parent->SetSpherePackFlag(SPF_SUPERSPHERE);

	mov	edx, eax
	mov	DWORD PTR [esi+52], eax
	or	edx, 1

; 515  :       #if DEMO
; 516  :       parent->SetColor( GetColor() );

	mov	ecx, ebx
	mov	DWORD PTR [esi+52], edx
	call	?GetColor@SpherePackFactory@@QAEIXZ	; SpherePackFactory::GetColor

; 517  :       #endif
; 518  :       parent->AddChild(pack);

	push	edi
	mov	ecx, esi
	mov	DWORD PTR [esi+72], eax
	call	?AddChild@SpherePack@@QAEXPAV1@@Z	; SpherePack::AddChild

; 519  : 
; 520  :       supersphere->AddChild(parent);

	mov	ecx, DWORD PTR _supersphere$[ebp]
	push	esi
	call	?AddChild@SpherePack@@QAEXPAV1@@Z	; SpherePack::AddChild

; 521  : 
; 522  :       parent->Recompute(mSuperSphereGravy);

	mov	eax, DWORD PTR [ebx+112]
	mov	ecx, esi
	push	eax
	call	?Recompute@SpherePack@@QAE_NM@Z		; SpherePack::Recompute

; 523  :       pack->ComputeBindingDistance(parent);

	push	esi
	mov	ecx, edi
	call	?ComputeBindingDistance@SpherePack@@QAEXPAV1@@Z ; SpherePack::ComputeBindingDistance

; 524  : 
; 525  :       if ( parent->HasSpherePackFlag(SPF_LEAF_TREE) )

	test	BYTE PTR [esi+52], 4
	je	SHORT $L16627

; 526  :       {
; 527  :         // need to create parent association!
; 528  :         SpherePack *link = AddSphere( parent->GetPos(), parent->GetRadius(), parent, SPF_ROOT_TREE);

	mov	ecx, DWORD PTR [esi+12]
	push	2
	mov	edx, ecx
	push	esi
	mov	DWORD PTR $T16622[ebp], ecx
	push	edx
	push	esi
	mov	ecx, ebx
	call	?AddSphere@SpherePackFactory@@QAEPAVSpherePack@@ABV?$Vector3d@M@@MPAXH@Z ; SpherePackFactory::AddSphere

; 529  :         parent->SetUserData(link); // hook him up!!

	mov	DWORD PTR [esi+64], eax
$L16627:

; 530  :       }
; 531  : 
; 532  :     }
; 533  :   }
; 534  : 
; 535  :   pack->ClearSpherePackFlag(SPF_INTEGRATE); // we've been integrated!

	mov	eax, DWORD PTR [edi+52]
	and	al, -33					; ffffffdfH
	mov	DWORD PTR [edi+52], eax

; 536  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?Integrate@SpherePackFactory@@QAEXPAVSpherePack@@0M@Z ENDP ; SpherePackFactory::Integrate
_TEXT	ENDS
;	COMDAT ?Recompute@SpherePack@@QAE_NM@Z
_TEXT	SEGMENT
_gravy$ = 8
_total$ = -16
_count$ = -4
_oldpos$12788 = -28
_maxradius$12789 = -4
?Recompute@SpherePack@@QAE_NM@Z PROC NEAR		; SpherePack::Recompute, COMDAT

; 248  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	ebx
	push	esi
	push	edi
	mov	edi, ecx

; 249  :   if ( !mChildren ) return true; // kill it!

	mov	esi, DWORD PTR [edi+32]
	test	esi, esi
	jne	SHORT $L12777
	mov	al, 1

; 313  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$L12777:

; 250  :   if ( HasSpherePackFlag(SPF_ROOTNODE) ) return false; // don't recompute root nodes!

	test	BYTE PTR [edi+52], 8
	jne	$L16743

; 251  : 
; 252  :   #if 1
; 253  :   // recompute bounding sphere!
; 254  :   Vector3d<float> total(0,0,0);
; 255  :   int count=0;

	xor	ebx, ebx
	mov	DWORD PTR _total$[ebp], 0

; 256  :   SpherePack *pack = mChildren;
; 257  :   while ( pack )

	test	esi, esi
	mov	DWORD PTR _total$[ebp+4], 0
	mov	DWORD PTR _total$[ebp+8], 0
	je	$L12799
$L12783:

; 258  :   {
; 259  :     total+=pack->mCenter;

	mov	ecx, DWORD PTR [esi]
	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR [eax+8], ecx
	lea	ecx, DWORD PTR _total$[ebp]
	call	??Y?$Vector3d@M@@QAEXV0@@Z		; Vector3d<float>::operator+=

; 260  :     count++;
; 261  :     pack = pack->GetNextSibling();

	mov	esi, DWORD PTR [esi+36]
	inc	ebx
	test	esi, esi
	jne	SHORT $L12783

; 262  :   }
; 263  : 
; 264  :   if ( count )

	test	ebx, ebx
	mov	DWORD PTR _count$[ebp], ebx
	je	$L12799

; 265  :   {
; 266  :     float recip = 1.0f / float(count);

	fild	DWORD PTR _count$[ebp]

; 267  :     total*=recip;
; 268  : 
; 269  :     Vector3d<float> oldpos = mCenter;

	mov	edx, DWORD PTR [edi]
	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+8]

; 270  : 
; 271  :     mCenter = total; // new origin!
; 272  :     float maxradius = 0;

	mov	DWORD PTR _maxradius$12789[ebp], esi
	fdivr	DWORD PTR __real@4@3fff8000000000000000

; 273  : 
; 274  :     pack = mChildren;

	mov	esi, DWORD PTR [edi+32]
	mov	DWORD PTR _oldpos$12788[ebp], edx
	mov	DWORD PTR _oldpos$12788[ebp+4], eax
	mov	DWORD PTR _oldpos$12788[ebp+8], ecx

; 275  : 
; 276  :     while ( pack )

	test	esi, esi
	fld	DWORD PTR _total$[ebp]
	fmul	ST(0), ST(1)
	fstp	DWORD PTR _total$[ebp]
	fld	DWORD PTR _total$[ebp+4]
	fmul	ST(0), ST(1)
	mov	edx, DWORD PTR _total$[ebp]
	mov	DWORD PTR [edi], edx
	fstp	DWORD PTR _total$[ebp+4]
	mov	eax, DWORD PTR _total$[ebp+4]
	fmul	DWORD PTR _total$[ebp+8]
	mov	DWORD PTR [edi+4], eax
	fst	DWORD PTR _total$[ebp+8]
	fstp	DWORD PTR [edi+8]
	je	SHORT $L12792
$L12791:

; 277  :     {
; 278  :       float dist = DistanceSquared(pack);

	push	esi
	mov	ecx, edi
	call	?Distance2@?$Vector3d@M@@QBEMABV1@@Z	; Vector3d<float>::Distance2

; 279  :       float radius = sqrtf(dist) + pack->GetRadius();

	fsqrt
	fadd	DWORD PTR [esi+12]

; 280  :       if ( radius > maxradius )

	fcom	DWORD PTR _maxradius$12789[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L16742

; 281  :       {
; 282  :         maxradius = radius;

	fst	DWORD PTR _maxradius$12789[ebp]

; 283  :         if ( (maxradius+gravy) >= GetRadius() )

	fadd	DWORD PTR _gravy$[ebp]
	fld	DWORD PTR [edi+12]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L16740
	jmp	SHORT $L12796
$L16742:

; 280  :       if ( radius > maxradius )

	fstp	ST(0)
$L12796:

; 286  :           ClearSpherePackFlag(SPF_RECOMPUTE);
; 287  :           return false;
; 288  :         }
; 289  :       }
; 290  :       pack = pack->GetNextSibling();

	mov	esi, DWORD PTR [esi+36]
	test	esi, esi
	jne	SHORT $L12791
$L12792:

; 291  :     }
; 292  : 
; 293  :     maxradius+=gravy;

	fld	DWORD PTR _maxradius$12789[ebp]
	fadd	DWORD PTR _gravy$[ebp]

; 294  : 
; 295  :     SetRadius(maxradius);
; 296  : 
; 297  :     // now all children have to recompute binding distance!!
; 298  :     pack = mChildren;

	mov	ecx, DWORD PTR [edi+32]

; 299  : 
; 300  :     while ( pack )

	xor	edx, edx
	cmp	ecx, edx
	fst	DWORD PTR [edi+12]
	fld	ST(0)
	fmul	ST(0), ST(1)
	fstp	DWORD PTR [edi+16]
	fstp	ST(0)
	je	SHORT $L12799
$L12798:

; 301  :     {
; 302  :       pack->ComputeBindingDistance(this);

	fld	DWORD PTR [edi+12]
	fsub	DWORD PTR [ecx+12]
	fst	DWORD PTR [ecx+60]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L16724
	mov	DWORD PTR [ecx+60], edx
	jmp	SHORT $L16725
$L16740:

; 284  :         {
; 285  :           mCenter = oldpos;

	mov	eax, DWORD PTR _oldpos$12788[ebp+8]
	mov	ecx, DWORD PTR _oldpos$12788[ebp]
	mov	edx, DWORD PTR _oldpos$12788[ebp+4]
	mov	DWORD PTR [edi+8], eax

; 304  :     }
; 305  : 
; 306  :   }
; 307  : 
; 308  :   #endif
; 309  : 
; 310  :   ClearSpherePackFlag(SPF_RECOMPUTE);

	mov	eax, DWORD PTR [edi+52]
	mov	DWORD PTR [edi], ecx
	and	al, -17					; ffffffefH
	mov	DWORD PTR [edi+4], edx
	mov	DWORD PTR [edi+52], eax

; 311  : 
; 312  :   return false;

	xor	al, al

; 313  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4

; 301  :     {
; 302  :       pack->ComputeBindingDistance(this);

$L16724:
	fld	DWORD PTR [ecx+60]
	fld	ST(0)
	fmul	ST(0), ST(1)
	fstp	DWORD PTR [ecx+60]
	fstp	ST(0)
$L16725:

; 303  :       pack = pack->GetNextSibling();

	mov	ecx, DWORD PTR [ecx+36]
	cmp	ecx, edx
	jne	SHORT $L12798
$L12799:

; 304  :     }
; 305  : 
; 306  :   }
; 307  : 
; 308  :   #endif
; 309  : 
; 310  :   ClearSpherePackFlag(SPF_RECOMPUTE);

	mov	eax, DWORD PTR [edi+52]
	and	al, -17					; ffffffefH
	mov	DWORD PTR [edi+52], eax
$L16743:

; 313  : }

	pop	edi
	pop	esi
	xor	al, al
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Recompute@SpherePack@@QAE_NM@Z ENDP			; SpherePack::Recompute
_TEXT	ENDS
;	COMDAT ?LostChild@SpherePack@@QAEXPAV1@@Z
_TEXT	SEGMENT
_t$ = 8
?LostChild@SpherePack@@QAEXPAV1@@Z PROC NEAR		; SpherePack::LostChild, COMDAT

; 317  : {

	push	ebp
	mov	ebp, esp

; 318  :   assert( mChildCount );
; 319  :   assert( mChildren );
; 320  : 
; 321  :   #ifdef _DEBUG  // debug validation code.
; 322  : 
; 323  :   SpherePack *pack = mChildren;
; 324  :   bool found = false;
; 325  :   while ( pack )
; 326  :   {
; 327  :     if ( pack == t )
; 328  :     {
; 329  :       assert( !found );
; 330  :       found = true;
; 331  :     }
; 332  :     pack = pack->GetNextSibling();
; 333  :   }
; 334  :   assert( found );
; 335  : 
; 336  :   #endif
; 337  : 
; 338  :   // first patch old linked list.. his previous now points to his next
; 339  :   SpherePack *prev = t->GetPrevSibling();

	mov	eax, DWORD PTR _t$[ebp]
	push	ebx
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [eax+40]

; 340  : 
; 341  :   if ( prev )
; 342  :   {
; 343  :     SpherePack *next = t->GetNextSibling();

	mov	eax, DWORD PTR [eax+36]
	xor	ebx, ebx
	push	edi
	cmp	ecx, ebx
	je	SHORT $L12807

; 344  :     prev->SetNextSibling( next ); // my previous now points to my next
; 345  :     if ( next ) next->SetPrevSibling(prev);

	cmp	eax, ebx
	mov	DWORD PTR [ecx+36], eax
	je	SHORT $L16762
	mov	DWORD PTR [eax+40], ecx

; 346  :     // list is patched!
; 347  :   }
; 348  :   else

	jmp	SHORT $L16762
$L12807:

; 349  :   {
; 350  :     SpherePack *next = t->GetNextSibling();
; 351  :     mChildren = next;
; 352  :     if ( mChildren) mChildren->SetPrevSibling(0);

	cmp	eax, ebx
	mov	DWORD PTR [esi+32], eax
	je	SHORT $L16762
	mov	DWORD PTR [eax+40], ebx
$L16762:

; 353  :   }
; 354  : 
; 355  :   mChildCount--;

	mov	eax, DWORD PTR [esi+56]
	dec	eax
	mov	DWORD PTR [esi+56], eax

; 356  : 
; 357  :   if ( !mChildCount && HasSpherePackFlag(SPF_SUPERSPHERE))

	jne	$L16872
	mov	eax, DWORD PTR [esi+52]
	test	al, 1
	je	$L16872

; 358  :   {
; 359  :     mFactory->Remove(this);

	mov	edi, DWORD PTR [esi+68]
	test	al, 8
	jne	SHORT $L16872
	test	al, 4
	je	SHORT $L16903
	mov	eax, DWORD PTR [esi+64]
	mov	ecx, edi
	push	eax
	call	?Remove@SpherePackFactory@@QAEXPAVSpherePack@@@Z ; SpherePackFactory::Remove
$L16903:
	mov	eax, DWORD PTR [esi+44]
	cmp	eax, ebx
	je	SHORT $L16868
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [esi+44], ebx
$L16868:
	mov	eax, DWORD PTR [esi+48]
	cmp	eax, ebx
	je	SHORT $L16869
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [esi+48], ebx
$L16869:
	mov	ecx, DWORD PTR [esi+28]
	cmp	ecx, ebx
	je	SHORT $L16870
	push	esi
	call	?LostChild@SpherePack@@QAEXPAV1@@Z	; SpherePack::LostChild
$L16870:
	mov	DWORD PTR [esi+28], ebx
	mov	eax, DWORD PTR [edi+20]
	cmp	esi, eax
	jne	SHORT $L16873
	mov	ecx, DWORD PTR [esi+20]
	mov	DWORD PTR [edi+20], ecx
$L16873:
	mov	ecx, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [esi+20]
	cmp	ecx, ebx
	je	SHORT $L16875
	cmp	eax, ebx
	mov	DWORD PTR [ecx+20], eax
	je	SHORT $L16895
	mov	DWORD PTR [eax+24], ecx
	jmp	SHORT $L16895
$L16875:
	cmp	eax, ebx
	mov	DWORD PTR [edi+28], eax
	je	SHORT $L16895
	mov	DWORD PTR [eax+24], ebx
$L16895:
	mov	eax, DWORD PTR [edi+32]
	mov	DWORD PTR [edi+32], esi
	mov	DWORD PTR [esi+24], ebx
	mov	DWORD PTR [esi+20], eax
	mov	ecx, DWORD PTR [edi+36]
	mov	eax, DWORD PTR [edi+40]
	dec	ecx
	inc	eax
	mov	DWORD PTR [edi+36], ecx
	mov	DWORD PTR [edi+40], eax
$L16872:
	pop	edi
	pop	esi
	pop	ebx

; 360  :   }
; 361  : }

	pop	ebp
	ret	4
?LostChild@SpherePack@@QAEXPAV1@@Z ENDP			; SpherePack::LostChild
_TEXT	ENDS
PUBLIC	?VisibilityTest@SpherePack@@QAEXABVFrustum@@PAVSpherePackCallback@@W4ViewState@@@Z ; SpherePack::VisibilityTest
PUBLIC	?FrustumTest@SpherePackFactory@@QAEXABVFrustum@@PAVSpherePackCallback@@@Z ; SpherePackFactory::FrustumTest
_TEXT	SEGMENT
_f$ = 8
_callback$ = 12
?FrustumTest@SpherePackFactory@@QAEXABVFrustum@@PAVSpherePackCallback@@@Z PROC NEAR ; SpherePackFactory::FrustumTest

; 540  : {

	push	ebp
	mov	ebp, esp

; 541  :   // test case here, just traverse children.
; 542  :   mCallback = callback;

	mov	eax, DWORD PTR _callback$[ebp]

; 543  :   mRoot->VisibilityTest(f,this,VS_PARTIAL);

	mov	edx, DWORD PTR _f$[ebp]
	push	1
	mov	DWORD PTR [ecx+12], eax
	push	ecx
	mov	ecx, DWORD PTR [ecx+4]
	push	edx
	call	?VisibilityTest@SpherePack@@QAEXABVFrustum@@PAVSpherePackCallback@@W4ViewState@@@Z ; SpherePack::VisibilityTest

; 544  : }

	pop	ebp
	ret	8
?FrustumTest@SpherePackFactory@@QAEXABVFrustum@@PAVSpherePackCallback@@@Z ENDP ; SpherePackFactory::FrustumTest
_TEXT	ENDS
EXTRN	?ViewVolumeTest@Frustum@@QBE?AW4ViewState@@ABV?$Vector3d@M@@M@Z:NEAR ; Frustum::ViewVolumeTest
_TEXT	SEGMENT
$T16916 = 16
_f$ = 8
_callback$ = 12
_state$ = 16
?VisibilityTest@SpherePack@@QAEXABVFrustum@@PAVSpherePackCallback@@W4ViewState@@@Z PROC NEAR ; SpherePack::VisibilityTest

; 548  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx

; 549  : 
; 550  :   if ( state == VS_PARTIAL )

	mov	ebx, DWORD PTR _f$[ebp]
	push	esi
	push	edi
	mov	edi, DWORD PTR _state$[ebp]
	mov	esi, ecx
	cmp	edi, 1
	jne	SHORT $L12886

; 551  :   {
; 552  :     state = f.ViewVolumeTest( mCenter, GetRadius() );

	mov	eax, DWORD PTR [esi+12]
	mov	ecx, eax
	mov	DWORD PTR $T16916[ebp], eax
	push	ecx
	push	esi
	mov	ecx, ebx
	call	?ViewVolumeTest@Frustum@@QBE?AW4ViewState@@ABV?$Vector3d@M@@M@Z ; Frustum::ViewVolumeTest
	mov	edi, eax

; 553  :     #if DEMO
; 554  :     if ( state != VS_OUTSIDE )

	cmp	edi, 2
	je	SHORT $L12886

; 555  :     {
; 556  :       DrawCircle( int(mCenter.x), int(mCenter.y), int(GetRadius()), 0x404040);

	fld	DWORD PTR [esi+12]
	fistp	QWORD PTR -8+[ebp]
	mov	edx, DWORD PTR -8+[ebp]
	push	4210752					; 00404040H
	push	edx
	fld	DWORD PTR [esi+4]
	fistp	QWORD PTR -8+[ebp]
	mov	eax, DWORD PTR -8+[ebp]
	push	eax
	fld	DWORD PTR [esi]
	fistp	QWORD PTR -8+[ebp]
	mov	ecx, DWORD PTR -8+[ebp]
	push	ecx
	call	?DrawCircle@@YAHHHHH@Z			; DrawCircle
	add	esp, 16					; 00000010H
$L12886:

; 557  :     }
; 558  :     #endif
; 559  :   }
; 560  : 
; 561  :   if ( HasSpherePackFlag(SPF_SUPERSPHERE) )

	mov	eax, DWORD PTR [esi+52]
	test	al, 1
	je	SHORT $L12887

; 562  :   {
; 563  : 
; 564  : 
; 565  :     if ( state == VS_OUTSIDE )

	cmp	edi, 2
	jne	SHORT $L12888

; 566  :     {
; 567  :       if ( HasSpherePackFlag(SPF_HIDDEN) ) return; // no state change

	test	al, 64					; 00000040H
	jne	$L12904

; 568  :       ClearSpherePackFlag( SpherePackFlag(SPF_INSIDE | SPF_PARTIAL) );

	and	eax, -385				; fffffe7fH

; 569  :       SetSpherePackFlag(SPF_HIDDEN);

	or	al, 64					; 00000040H

; 570  :     }
; 571  :     else

	jmp	SHORT $L16999
$L12888:

; 572  :     {
; 573  :       if ( state == VS_INSIDE )

	test	edi, edi
	jne	SHORT $L12891

; 574  :       {
; 575  :         if ( HasSpherePackFlag(SPF_INSIDE) ) return; // no state change

	test	ah, 1
	jne	$L12904

; 576  :         ClearSpherePackFlag( SpherePackFlag(SPF_PARTIAL | SPF_HIDDEN) );

	and	al, 63					; 0000003fH

; 577  :         SetSpherePackFlag(SPF_INSIDE);

	or	ah, 1

; 578  :       }
; 579  :       else

	jmp	SHORT $L16999
$L12891:

; 580  :       {
; 581  :         ClearSpherePackFlag( SpherePackFlag(SPF_HIDDEN | SPF_INSIDE) );

	and	eax, -321				; fffffebfH

; 582  :         SetSpherePackFlag(SPF_PARTIAL);

	or	al, -128				; ffffff80H
$L16999:
	mov	DWORD PTR [esi+52], eax

; 583  :       }
; 584  :     }
; 585  : 
; 586  :     SpherePack *pack = mChildren;

	mov	esi, DWORD PTR [esi+32]

; 587  : 
; 588  :     while ( pack )

	test	esi, esi
	je	$L12904
$L12896:

; 589  :     {
; 590  :       pack->VisibilityTest(f,callback,state);

	mov	edx, DWORD PTR _callback$[ebp]
	push	edi
	push	edx
	push	ebx
	mov	ecx, esi
	call	?VisibilityTest@SpherePack@@QAEXABVFrustum@@PAVSpherePackCallback@@W4ViewState@@@Z ; SpherePack::VisibilityTest

; 591  :       pack = pack->GetNextSibling();

	mov	esi, DWORD PTR [esi+36]
	test	esi, esi
	jne	SHORT $L12896
	pop	edi
	pop	esi
	pop	ebx

; 621  :         }
; 622  :         break;
; 623  :     }
; 624  : 
; 625  :   }
; 626  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$L12887:

; 592  :     }
; 593  : 
; 594  :   }
; 595  :   else
; 596  :   {
; 597  :     switch ( state )
; 598  :     {

	sub	edi, 0
	je	SHORT $L12903
	dec	edi
	je	SHORT $L12907
	dec	edi
	jne	SHORT $L12904

; 605  :         }
; 606  :         break;
; 607  :       case VS_OUTSIDE:
; 608  :         if ( !HasSpherePackFlag(SPF_HIDDEN) )

	test	al, 64					; 00000040H
	jne	SHORT $L12904

; 609  :         {
; 610  :           ClearSpherePackFlag( SpherePackFlag(SPF_INSIDE | SPF_PARTIAL) );
; 611  :           SetSpherePackFlag(SPF_HIDDEN);
; 612  :           callback->VisibilityCallback(f,this,state);

	mov	ecx, DWORD PTR _callback$[ebp]
	and	eax, -385				; fffffe7fH
	or	al, 64					; 00000040H
	push	2
	mov	DWORD PTR [esi+52], eax
	mov	eax, DWORD PTR [ecx]
	push	esi
	push	ebx
	call	DWORD PTR [eax]
	pop	edi
	pop	esi
	pop	ebx

; 621  :         }
; 622  :         break;
; 623  :     }
; 624  : 
; 625  :   }
; 626  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$L12907:

; 613  :         }
; 614  :         break;
; 615  :       case VS_PARTIAL:
; 616  :         if ( !HasSpherePackFlag(SPF_PARTIAL) )

	test	al, -128				; ffffff80H
	jne	SHORT $L12904

; 617  :         {
; 618  :           ClearSpherePackFlag( SpherePackFlag(SPF_INSIDE | SPF_HIDDEN) );
; 619  :           SetSpherePackFlag(SPF_PARTIAL);
; 620  :           callback->VisibilityCallback(f,this,state);

	mov	ecx, DWORD PTR _callback$[ebp]
	and	eax, -321				; fffffebfH
	or	al, -128				; ffffff80H
	push	1
	mov	DWORD PTR [esi+52], eax
	mov	edx, DWORD PTR [ecx]
	push	esi
	push	ebx
	call	DWORD PTR [edx]
	pop	edi
	pop	esi
	pop	ebx

; 621  :         }
; 622  :         break;
; 623  :     }
; 624  : 
; 625  :   }
; 626  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$L12903:

; 599  :       case VS_INSIDE:
; 600  :         if ( !HasSpherePackFlag(SPF_INSIDE) )

	test	ah, 1
	jne	SHORT $L12904

; 601  :         {
; 602  :           ClearSpherePackFlag( SpherePackFlag(SPF_HIDDEN | SPF_PARTIAL) );
; 603  :           SetSpherePackFlag(SPF_INSIDE);
; 604  :           callback->VisibilityCallback(f,this,state);

	mov	ecx, DWORD PTR _callback$[ebp]
	and	al, 63					; 0000003fH
	or	ah, 1
	push	0
	mov	DWORD PTR [esi+52], eax
	mov	eax, DWORD PTR [ecx]
	push	esi
	push	ebx
	call	DWORD PTR [eax]
$L12904:
	pop	edi
	pop	esi
	pop	ebx

; 621  :         }
; 622  :         break;
; 623  :     }
; 624  : 
; 625  :   }
; 626  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?VisibilityTest@SpherePack@@QAEXABVFrustum@@PAVSpherePackCallback@@W4ViewState@@@Z ENDP ; SpherePack::VisibilityTest
_TEXT	ENDS
PUBLIC	?RayTrace@SpherePack@@QAEXABV?$Vector3d@M@@0MPAVSpherePackCallback@@@Z ; SpherePack::RayTrace
PUBLIC	?RayTrace@SpherePackFactory@@QAEXABV?$Vector3d@M@@0PAVSpherePackCallback@@@Z ; SpherePackFactory::RayTrace
_TEXT	SEGMENT
_p1$ = 8
_p2$ = 12
_callback$ = 16
_dir$ = -24
_Diff$17014 = -12
?RayTrace@SpherePackFactory@@QAEXABV?$Vector3d@M@@0PAVSpherePackCallback@@@Z PROC NEAR ; SpherePackFactory::RayTrace

; 631  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 632  :   // test case here, just traverse children.
; 633  :   Vector3d<float> dir = p2-p1;

	mov	eax, DWORD PTR _p2$[ebp]
	mov	edx, DWORD PTR _p1$[ebp]
	fld	DWORD PTR [eax]
	fsub	DWORD PTR [edx]
	fstp	DWORD PTR _Diff$17014[ebp]
	fld	DWORD PTR [eax+4]
	fsub	DWORD PTR [edx+4]
	fstp	DWORD PTR _Diff$17014[ebp+4]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [edx+8]
	fst	DWORD PTR _Diff$17014[ebp+8]

; 634  :   float dist = dir.Normalize();

	fmul	DWORD PTR _Diff$17014[ebp+8]
	fld	DWORD PTR _Diff$17014[ebp+4]
	fmul	DWORD PTR _Diff$17014[ebp+4]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _Diff$17014[ebp]
	fmul	DWORD PTR _Diff$17014[ebp]
	faddp	ST(1), ST(0)
	fsqrt
	fcom	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L17029
	fld	DWORD PTR _Diff$17014[ebp]
	fdiv	ST(0), ST(1)
	fstp	DWORD PTR _dir$[ebp]
	fld	DWORD PTR _Diff$17014[ebp+4]
	fdiv	ST(0), ST(1)
	fstp	DWORD PTR _dir$[ebp+4]
	fld	DWORD PTR _Diff$17014[ebp+8]
	fdiv	ST(0), ST(1)
	fstp	DWORD PTR _dir$[ebp+8]
	jmp	SHORT $L17030
$L17029:
	mov	DWORD PTR _dir$[ebp+8], 0
	mov	DWORD PTR _dir$[ebp+4], 0
	mov	DWORD PTR _dir$[ebp], 0
$L17030:

; 635  :   mCallback = callback;

	mov	eax, DWORD PTR _callback$[ebp]

; 636  :   mRoot->RayTrace(p1,dir,dist,this);

	push	ecx
	push	ecx
	mov	DWORD PTR [ecx+12], eax
	mov	ecx, DWORD PTR [ecx+4]
	lea	eax, DWORD PTR _dir$[ebp]
	fstp	DWORD PTR [esp]
	push	eax
	push	edx
	call	?RayTrace@SpherePack@@QAEXABV?$Vector3d@M@@0MPAVSpherePackCallback@@@Z ; SpherePack::RayTrace

; 637  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?RayTrace@SpherePackFactory@@QAEXABV?$Vector3d@M@@0PAVSpherePackCallback@@@Z ENDP ; SpherePackFactory::RayTrace
_TEXT	ENDS
EXTRN	?RayIntersection@Sphere@@QAE_NABV?$Vector3d@M@@0MPAV2@@Z:NEAR ; Sphere::RayIntersection
EXTRN	?RayIntersectionInFront@Sphere@@QAE_NABV?$Vector3d@M@@0PAV2@@Z:NEAR ; Sphere::RayIntersectionInFront
_TEXT	SEGMENT
_p1$ = 8
_dir$ = 12
_distance$ = 16
_callback$ = 20
_sect$12933 = -12
?RayTrace@SpherePack@@QAEXABV?$Vector3d@M@@0MPAVSpherePackCallback@@@Z PROC NEAR ; SpherePack::RayTrace

; 643  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	mov	esi, ecx
	push	edi

; 644  :   bool hit = false;
; 645  : 
; 646  :   if ( HasSpherePackFlag(SPF_SUPERSPHERE) )

	test	BYTE PTR [esi+52], 1
	je	SHORT $L12926

; 647  :   {
; 648  : 
; 649  :     hit = RayIntersectionInFront(p1,dir,0);

	mov	edi, DWORD PTR _dir$[ebp]
	mov	ebx, DWORD PTR _p1$[ebp]
	push	0
	push	edi
	push	ebx
	call	?RayIntersectionInFront@Sphere@@QAE_NABV?$Vector3d@M@@0PAV2@@Z ; Sphere::RayIntersectionInFront

; 650  : 
; 651  :     if ( hit )

	test	al, al
	je	$L12934

; 652  :     {
; 653  :       #if DEMO
; 654  :       DrawCircle( int(mCenter.x), int(mCenter.y), int(GetRadius()), 0x404040);

	fld	DWORD PTR [esi+12]
	fistp	QWORD PTR -8+[ebp]
	mov	eax, DWORD PTR -8+[ebp]
	push	4210752					; 00404040H
	push	eax
	fld	DWORD PTR [esi+4]
	fistp	QWORD PTR -8+[ebp]
	mov	ecx, DWORD PTR -8+[ebp]
	push	ecx
	fld	DWORD PTR [esi]
	fistp	QWORD PTR -8+[ebp]
	mov	edx, DWORD PTR -8+[ebp]
	push	edx
	call	?DrawCircle@@YAHHHHH@Z			; DrawCircle

; 655  :       #endif
; 656  :       SpherePack *pack = mChildren;

	mov	esi, DWORD PTR [esi+32]
	add	esp, 16					; 00000010H

; 657  : 
; 658  :       while ( pack )

	test	esi, esi
	je	SHORT $L12934
$L12930:

; 659  :       {
; 660  :         pack->RayTrace(p1,dir,distance,callback);

	mov	eax, DWORD PTR _callback$[ebp]
	mov	ecx, DWORD PTR _distance$[ebp]
	push	eax
	push	ecx
	push	edi
	push	ebx
	mov	ecx, esi
	call	?RayTrace@SpherePack@@QAEXABV?$Vector3d@M@@0MPAVSpherePackCallback@@@Z ; SpherePack::RayTrace

; 661  :         pack = pack->GetNextSibling();

	mov	esi, DWORD PTR [esi+36]
	test	esi, esi
	jne	SHORT $L12930
	pop	edi
	pop	esi
	pop	ebx

; 673  :   	}
; 674  :   }
; 675  : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$L12926:

; 662  :       }
; 663  :     }
; 664  : 
; 665  :   }
; 666  :   else
; 667  :   {
; 668  :     Vector3d<float> sect;
; 669  :     hit = RayIntersection(p1,dir,distance,&sect);

	mov	edi, DWORD PTR _distance$[ebp]
	mov	ebx, DWORD PTR _dir$[ebp]
	mov	eax, DWORD PTR _p1$[ebp]
	lea	edx, DWORD PTR _sect$12933[ebp]
	push	edx
	push	edi
	push	ebx
	push	eax
	mov	ecx, esi
	call	?RayIntersection@Sphere@@QAE_NABV?$Vector3d@M@@0MPAV2@@Z ; Sphere::RayIntersection

; 670  :   	if ( hit )

	test	al, al
	je	SHORT $L12934

; 671  : 	  {
; 672  :   	  callback->RayTraceCallback(p1,dir,distance,sect,this);

	mov	ecx, DWORD PTR _callback$[ebp]
	lea	eax, DWORD PTR _sect$12933[ebp]
	push	esi
	push	eax
	mov	eax, DWORD PTR _p1$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edi
	push	ebx
	push	eax
	call	DWORD PTR [edx+4]
$L12934:
	pop	edi
	pop	esi
	pop	ebx

; 673  :   	}
; 674  :   }
; 675  : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?RayTrace@SpherePack@@QAEXABV?$Vector3d@M@@0MPAVSpherePackCallback@@@Z ENDP ; SpherePack::RayTrace
_p1$ = 8
_dir$ = 12
_distance$ = 16
_sphere$ = 24
?RayTraceCallback@SpherePackFactory@@UAEXABV?$Vector3d@M@@0M0PAVSpherePack@@@Z PROC NEAR ; SpherePackFactory::RayTraceCallback

; 682  : {

	push	ebp
	mov	ebp, esp

; 683  :   SpherePack *link = (SpherePack *) sphere->GetUserData();

	mov	eax, DWORD PTR _sphere$[ebp]
	mov	eax, DWORD PTR [eax+64]

; 684  :   if ( link ) link->RayTrace(p1,dir,distance,mCallback);

	test	eax, eax
	je	SHORT $L12945
	mov	ecx, DWORD PTR [ecx+12]
	mov	edx, DWORD PTR _distance$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _dir$[ebp]
	push	edx
	mov	edx, DWORD PTR _p1$[ebp]
	push	ecx
	push	edx
	mov	ecx, eax
	call	?RayTrace@SpherePack@@QAEXABV?$Vector3d@M@@0MPAVSpherePackCallback@@@Z ; SpherePack::RayTrace
$L12945:

; 685  : };

	pop	ebp
	ret	20					; 00000014H
?RayTraceCallback@SpherePackFactory@@UAEXABV?$Vector3d@M@@0M0PAVSpherePack@@@Z ENDP ; SpherePackFactory::RayTraceCallback
_TEXT	ENDS
PUBLIC	?RangeTest@SpherePack@@QAEXABV?$Vector3d@M@@MPAVSpherePackCallback@@W4ViewState@@@Z ; SpherePack::RangeTest
PUBLIC	?RangeTest@SpherePackFactory@@QAEXABV?$Vector3d@M@@MPAVSpherePackCallback@@@Z ; SpherePackFactory::RangeTest
_TEXT	SEGMENT
_center$ = 8
_radius$ = 12
_callback$ = 16
?RangeTest@SpherePackFactory@@QAEXABV?$Vector3d@M@@MPAVSpherePackCallback@@@Z PROC NEAR ; SpherePackFactory::RangeTest

; 689  : {

	push	ebp
	mov	ebp, esp

; 690  :   mCallback = callback;

	mov	eax, DWORD PTR _callback$[ebp]

; 691  :   mRoot->RangeTest(center,radius,this,VS_PARTIAL);

	mov	edx, DWORD PTR _radius$[ebp]
	mov	DWORD PTR [ecx+12], eax
	mov	eax, DWORD PTR _center$[ebp]
	push	1
	push	ecx
	mov	ecx, DWORD PTR [ecx+4]
	push	edx
	push	eax
	call	?RangeTest@SpherePack@@QAEXABV?$Vector3d@M@@MPAVSpherePackCallback@@W4ViewState@@@Z ; SpherePack::RangeTest

; 692  : }

	pop	ebp
	ret	12					; 0000000cH
?RangeTest@SpherePackFactory@@QAEXABV?$Vector3d@M@@MPAVSpherePackCallback@@@Z ENDP ; SpherePackFactory::RangeTest
_p$ = 8
_distance$ = 12
_callback$ = 16
_state$ = 20
?RangeTest@SpherePack@@QAEXABV?$Vector3d@M@@MPAVSpherePackCallback@@W4ViewState@@@Z PROC NEAR ; SpherePack::RangeTest

; 699  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx

; 700  :   if ( state == VS_PARTIAL )

	mov	ebx, DWORD PTR _p$[ebp]
	push	esi
	push	edi
	mov	edi, DWORD PTR _state$[ebp]
	mov	esi, ecx
	cmp	edi, 1
	jne	SHORT $L12962

; 701  :   {
; 702  :     float d = p.Distance(mCenter);

	fld	DWORD PTR [esi]
	fsub	DWORD PTR [ebx]
	fld	DWORD PTR [esi+4]
	fsub	DWORD PTR [ebx+4]
	fld	DWORD PTR [esi+8]
	fsub	DWORD PTR [ebx+8]
	fstp	DWORD PTR 20+[ebp]
	fld	ST(0)
	fmul	ST(0), ST(1)
	fld	DWORD PTR 20+[ebp]
	fmul	DWORD PTR 20+[ebp]

; 720  :     }
; 721  : 
; 722  :   }
; 723  :   else
; 724  :   {
; 725  :     callback->RangeTestCallback(p,distance,this,state);

	faddp	ST(1), ST(0)
	fld	ST(2)
	fmul	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fsqrt
	fstp	ST(2)
	fstp	ST(0)
	fld	ST(0)
	fsub	DWORD PTR _distance$[ebp]
	fld	DWORD PTR [esi+12]
	fcompp
	fnstsw	ax
	test	ah, 1
	jne	$L17098
	fld	DWORD PTR [esi+12]
	fadd	ST(0), ST(1)
	fcomp	DWORD PTR _distance$[ebp]
	fnstsw	ax
	test	ah, 1
	fstp	ST(0)
	je	SHORT $L12962

; 703  :     if ( (d-distance) > GetRadius() ) return;;
; 704  :     if ( (GetRadius()+d) < distance ) state = VS_INSIDE;

	xor	edi, edi
$L12962:

; 705  :   }
; 706  : 
; 707  :   if ( HasSpherePackFlag(SPF_SUPERSPHERE) )

	test	BYTE PTR [esi+52], 1
	je	SHORT $L12963

; 708  :   {
; 709  :     #if DEMO
; 710  :     if ( state == VS_PARTIAL )

	cmp	edi, 1
	jne	SHORT $L12964

; 711  :     {
; 712  :       DrawCircle( int(mCenter.x), int(mCenter.y), int(GetRadius()), 0x404040);

	fld	DWORD PTR [esi+12]
	fistp	QWORD PTR -8+[ebp]
	mov	eax, DWORD PTR -8+[ebp]
	push	4210752					; 00404040H
	push	eax
	fld	DWORD PTR [esi+4]
	fistp	QWORD PTR -8+[ebp]
	mov	ecx, DWORD PTR -8+[ebp]
	push	ecx
	fld	DWORD PTR [esi]
	fistp	QWORD PTR -8+[ebp]
	mov	edx, DWORD PTR -8+[ebp]
	push	edx
	call	?DrawCircle@@YAHHHHH@Z			; DrawCircle
	add	esp, 16					; 00000010H
$L12964:

; 713  :     }
; 714  :     #endif
; 715  :     SpherePack *pack = mChildren;

	mov	esi, DWORD PTR [esi+32]

; 716  :     while ( pack )

	test	esi, esi
	je	SHORT $L12969
$L12967:

; 717  :     {
; 718  :       pack->RangeTest(p,distance,callback,state);

	mov	eax, DWORD PTR _callback$[ebp]
	mov	ecx, DWORD PTR _distance$[ebp]
	push	edi
	push	eax
	push	ecx
	push	ebx
	mov	ecx, esi
	call	?RangeTest@SpherePack@@QAEXABV?$Vector3d@M@@MPAVSpherePackCallback@@W4ViewState@@@Z ; SpherePack::RangeTest

; 719  :       pack = pack->GetNextSibling();

	mov	esi, DWORD PTR [esi+36]
	test	esi, esi
	jne	SHORT $L12967
	pop	edi
	pop	esi
	pop	ebx

; 726  :   }
; 727  : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$L12963:

; 720  :     }
; 721  : 
; 722  :   }
; 723  :   else
; 724  :   {
; 725  :     callback->RangeTestCallback(p,distance,this,state);

	mov	ecx, DWORD PTR _callback$[ebp]
	mov	eax, DWORD PTR _distance$[ebp]
	push	edi
	push	esi
	mov	edx, DWORD PTR [ecx]
	push	eax
	push	ebx
	call	DWORD PTR [edx+8]
	pop	edi
	pop	esi
	pop	ebx

; 726  :   }
; 727  : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$L17098:

; 720  :     }
; 721  : 
; 722  :   }
; 723  :   else
; 724  :   {
; 725  :     callback->RangeTestCallback(p,distance,this,state);

	fstp	ST(0)
$L12969:
	pop	edi
	pop	esi
	pop	ebx

; 726  :   }
; 727  : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?RangeTest@SpherePack@@QAEXABV?$Vector3d@M@@MPAVSpherePackCallback@@W4ViewState@@@Z ENDP ; SpherePack::RangeTest
_p$ = 8
_distance$ = 12
_sphere$ = 16
_state$ = 20
?RangeTestCallback@SpherePackFactory@@UAEXABV?$Vector3d@M@@MPAVSpherePack@@W4ViewState@@@Z PROC NEAR ; SpherePackFactory::RangeTestCallback

; 730  : {

	push	ebp
	mov	ebp, esp

; 731  :   SpherePack *link = (SpherePack *) sphere->GetUserData();

	mov	eax, DWORD PTR _sphere$[ebp]
	mov	eax, DWORD PTR [eax+64]

; 732  :   if ( link ) link->RangeTest(p,distance,mCallback,state);

	test	eax, eax
	je	SHORT $L12979
	mov	edx, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [ecx+12]
	push	edx
	mov	edx, DWORD PTR _distance$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _p$[ebp]
	push	edx
	push	ecx
	mov	ecx, eax
	call	?RangeTest@SpherePack@@QAEXABV?$Vector3d@M@@MPAVSpherePackCallback@@W4ViewState@@@Z ; SpherePack::RangeTest
$L12979:

; 733  : };

	pop	ebp
	ret	16					; 00000010H
?RangeTestCallback@SpherePackFactory@@UAEXABV?$Vector3d@M@@MPAVSpherePack@@W4ViewState@@@Z ENDP ; SpherePackFactory::RangeTestCallback
_TEXT	ENDS
PUBLIC	?Reset@SpherePack@@QAEXXZ			; SpherePack::Reset
PUBLIC	?Reset@SpherePackFactory@@QAEXXZ		; SpherePackFactory::Reset
_TEXT	SEGMENT
?Reset@SpherePackFactory@@QAEXXZ PROC NEAR		; SpherePackFactory::Reset

; 737  : {

	push	esi
	push	edi
	mov	edi, ecx

; 738  :   mRoot->Reset();

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [eax+52]
	mov	esi, DWORD PTR [eax+32]
	and	ecx, -449				; fffffe3fH
	test	esi, esi
	mov	DWORD PTR [eax+52], ecx
	je	SHORT $L17115
$L17114:
	mov	ecx, esi
	call	?Reset@SpherePack@@QAEXXZ		; SpherePack::Reset
	mov	esi, DWORD PTR [esi+36]
	test	esi, esi
	jne	SHORT $L17114
$L17115:

; 739  :   mLeaf->Reset();

	mov	eax, DWORD PTR [edi+8]
	mov	ecx, DWORD PTR [eax+52]
	mov	esi, DWORD PTR [eax+32]
	and	ecx, -449				; fffffe3fH
	test	esi, esi
	mov	DWORD PTR [eax+52], ecx
	je	SHORT $L17132
$L17131:
	mov	ecx, esi
	call	?Reset@SpherePack@@QAEXXZ		; SpherePack::Reset
	mov	esi, DWORD PTR [esi+36]
	test	esi, esi
	jne	SHORT $L17131
$L17132:
	pop	edi
	pop	esi

; 740  : }

	ret	0
?Reset@SpherePackFactory@@QAEXXZ ENDP			; SpherePackFactory::Reset
?Reset@SpherePack@@QAEXXZ PROC NEAR			; SpherePack::Reset

; 745  :   ClearSpherePackFlag( SpherePackFlag(SPF_HIDDEN | SPF_PARTIAL | SPF_INSIDE) );

	mov	edx, DWORD PTR [ecx+52]
	push	esi

; 746  : 
; 747  :   SpherePack *pack = mChildren;

	mov	esi, DWORD PTR [ecx+32]
	and	edx, -449				; fffffe3fH

; 748  :   while ( pack )

	test	esi, esi
	mov	DWORD PTR [ecx+52], edx
	je	SHORT $L12991
$L12990:

; 749  :   {
; 750  :     pack->Reset();

	mov	ecx, esi
	call	?Reset@SpherePack@@QAEXXZ		; SpherePack::Reset

; 751  :     pack = pack->GetNextSibling();

	mov	esi, DWORD PTR [esi+36]
	test	esi, esi
	jne	SHORT $L12990
$L12991:
	pop	esi

; 752  :   }
; 753  : }

	ret	0
?Reset@SpherePack@@QAEXXZ ENDP				; SpherePack::Reset
_f$ = 8
_sphere$ = 12
_state$ = 16
?VisibilityCallback@SpherePackFactory@@UAEXABVFrustum@@PAVSpherePack@@W4ViewState@@@Z PROC NEAR ; SpherePackFactory::VisibilityCallback

; 756  : {

	push	ebp
	mov	ebp, esp

; 757  :   SpherePack *link = (SpherePack *) sphere->GetUserData();

	mov	eax, DWORD PTR _sphere$[ebp]
	mov	eax, DWORD PTR [eax+64]

; 758  :   if ( link ) link->VisibilityTest(f,mCallback,state);

	test	eax, eax
	je	SHORT $L13000
	mov	edx, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [ecx+12]
	push	edx
	mov	edx, DWORD PTR _f$[ebp]
	push	ecx
	push	edx
	mov	ecx, eax
	call	?VisibilityTest@SpherePack@@QAEXABVFrustum@@PAVSpherePackCallback@@W4ViewState@@@Z ; SpherePack::VisibilityTest
$L13000:

; 759  : }

	pop	ebp
	ret	12					; 0000000cH
?VisibilityCallback@SpherePackFactory@@UAEXABVFrustum@@PAVSpherePack@@W4ViewState@@@Z ENDP ; SpherePackFactory::VisibilityCallback
_TEXT	ENDS
;	COMDAT ??0?$Vector3d@M@@QAE@ABV0@@Z
_TEXT	SEGMENT
_a$ = 8
??0?$Vector3d@M@@QAE@ABV0@@Z PROC NEAR			; Vector3d<float>::Vector3d<float>, COMDAT

; 30   :   Vector3d(const Vector3d &a) // constructor copies existing vector.

	push	ebp
	mov	ebp, esp
	mov	eax, ecx

; 31   :   {
; 32   :     x = a.x;

	mov	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 33   :     y = a.y;

	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx

; 34   :     z = a.z;

	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ecx

; 35   :   };

	pop	ebp
	ret	4
??0?$Vector3d@M@@QAE@ABV0@@Z ENDP			; Vector3d<float>::Vector3d<float>
_TEXT	ENDS
;	COMDAT ??0?$Vector3d@M@@QAE@MMM@Z
_TEXT	SEGMENT
_a$ = 8
_b$ = 12
_c$ = 16
??0?$Vector3d@M@@QAE@MMM@Z PROC NEAR			; Vector3d<float>::Vector3d<float>, COMDAT

; 37   :   Vector3d(Type a,Type b,Type c) // construct with initial point.

	push	ebp
	mov	ebp, esp

; 38   :   {
; 39   :     x = a;
; 40   :     y = b;

	mov	edx, DWORD PTR _b$[ebp]
	mov	eax, ecx
	mov	ecx, DWORD PTR _a$[ebp]
	mov	DWORD PTR [eax], ecx

; 41   :     z = c;

	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax+8], ecx

; 42   :   };

	pop	ebp
	ret	12					; 0000000cH
??0?$Vector3d@M@@QAE@MMM@Z ENDP				; Vector3d<float>::Vector3d<float>
_TEXT	ENDS
;	COMDAT ??4?$Vector3d@M@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
_A$ = 8
??4?$Vector3d@M@@QAEAAV0@ABV0@@Z PROC NEAR		; Vector3d<float>::operator=, COMDAT

; 59   :       { x=A.x; y=A.y; z=A.z;

	push	ebp
	mov	ebp, esp
	mov	eax, ecx
	mov	ecx, DWORD PTR _A$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ecx

; 60   :         return(*this);  };

	pop	ebp
	ret	4
??4?$Vector3d@M@@QAEAAV0@ABV0@@Z ENDP			; Vector3d<float>::operator=
_TEXT	ENDS
;	COMDAT ??Y?$Vector3d@M@@QAEXV0@@Z
_TEXT	SEGMENT
_A$ = 8
??Y?$Vector3d@M@@QAEXV0@@Z PROC NEAR			; Vector3d<float>::operator+=, COMDAT

; 82   :       { x+=A.x; y+=A.y; z+=A.z; };

	push	ebp
	mov	ebp, esp
	fld	DWORD PTR _A$[ebp]
	fadd	DWORD PTR [ecx]
	fstp	DWORD PTR [ecx]
	fld	DWORD PTR _A$[ebp+4]
	fadd	DWORD PTR [ecx+4]
	fstp	DWORD PTR [ecx+4]
	fld	DWORD PTR _A$[ebp+8]
	fadd	DWORD PTR [ecx+8]
	fstp	DWORD PTR [ecx+8]
	pop	ebp
	ret	12					; 0000000cH
??Y?$Vector3d@M@@QAEXV0@@Z ENDP				; Vector3d<float>::operator+=
_TEXT	ENDS
;	COMDAT ??X?$Vector3d@M@@QAEXM@Z
_TEXT	SEGMENT
_s$ = 8
??X?$Vector3d@M@@QAEXM@Z PROC NEAR			; Vector3d<float>::operator*=, COMDAT

; 86   :       {x*=s; y*=s; z*=s;}

	push	ebp
	mov	ebp, esp
	fld	DWORD PTR _s$[ebp]
	fmul	DWORD PTR [ecx]
	fstp	DWORD PTR [ecx]
	fld	DWORD PTR _s$[ebp]
	fmul	DWORD PTR [ecx+4]
	fstp	DWORD PTR [ecx+4]
	fld	DWORD PTR _s$[ebp]
	fmul	DWORD PTR [ecx+8]
	fstp	DWORD PTR [ecx+8]
	pop	ebp
	ret	4
??X?$Vector3d@M@@QAEXM@Z ENDP				; Vector3d<float>::operator*=
_TEXT	ENDS
;	COMDAT ?Distance2@?$Vector3d@M@@QBEMABV1@@Z
_TEXT	SEGMENT
_a$ = 8
?Distance2@?$Vector3d@M@@QBEMABV1@@Z PROC NEAR		; Vector3d<float>::Distance2, COMDAT

; 167  :   {

	push	ebp
	mov	ebp, esp

; 168  :     float dx = a.x - x;

	mov	eax, DWORD PTR _a$[ebp]
	fld	DWORD PTR [eax]
	fsub	DWORD PTR [ecx]

; 169  :     float dy = a.y - y;

	fld	DWORD PTR [eax+4]
	fsub	DWORD PTR [ecx+4]

; 170  :     float dz = a.z - z;

	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [ecx+8]

; 171  :     return dx*dx + dy*dy + dz*dz;

	fld	ST(0)
	fmul	ST(0), ST(1)
	fld	ST(2)
	fmul	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fld	ST(3)
	fmul	ST(0), ST(4)
	faddp	ST(1), ST(0)
	fstp	ST(3)
	fstp	ST(0)
	fstp	ST(0)

; 172  :   };

	pop	ebp
	ret	4
?Distance2@?$Vector3d@M@@QBEMABV1@@Z ENDP		; Vector3d<float>::Distance2
_TEXT	ENDS
;	COMDAT ??1?$Pool@VSpherePack@@@@QAE@XZ
_TEXT	SEGMENT
??1?$Pool@VSpherePack@@@@QAE@XZ PROC NEAR		; Pool<SpherePack>::~Pool<SpherePack>, COMDAT

; 37   :     delete mData;

	mov	eax, DWORD PTR [ecx+8]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 38   :   };

	ret	0
??1?$Pool@VSpherePack@@@@QAE@XZ ENDP			; Pool<SpherePack>::~Pool<SpherePack>
_TEXT	ENDS
;	COMDAT ?Release@?$Pool@VSpherePack@@@@QAEXPAVSpherePack@@@Z
_TEXT	SEGMENT
_t$ = 8
?Release@?$Pool@VSpherePack@@@@QAEXPAVSpherePack@@@Z PROC NEAR ; Pool<SpherePack>::Release, COMDAT

; 137  :   {

	push	ebp
	mov	ebp, esp

; 138  : 
; 139  :     if ( t == mCurrent ) mCurrent = t->GetNext();

	mov	eax, DWORD PTR _t$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	eax, edx
	jne	SHORT $L13427
	mov	edx, DWORD PTR [eax+20]
	mov	DWORD PTR [ecx+4], edx
$L13427:

; 140  : 
; 141  :     // first patch old linked list.. his previous now points to his next
; 142  :     Type *prev = t->GetPrevious();
; 143  : 
; 144  :     if ( prev )
; 145  :     {
; 146  :       Type *next = t->GetNext();

	mov	edx, DWORD PTR [eax+20]
	push	esi
	mov	esi, DWORD PTR [eax+24]
	test	esi, esi
	je	SHORT $L13429

; 147  :       prev->SetNext( next ); // my previous now points to my next
; 148  :       if ( next ) next->SetPrevious(prev);

	test	edx, edx
	mov	DWORD PTR [esi+20], edx
	je	SHORT $L17190
	mov	DWORD PTR [edx+24], esi

; 149  :       // list is patched!
; 150  :     }
; 151  :     else

	jmp	SHORT $L17190
$L13429:

; 152  :     {
; 153  :       Type *next = t->GetNext();
; 154  :       mHead = next;
; 155  :       if ( mHead ) mHead->SetPrevious(0);

	test	edx, edx
	mov	DWORD PTR [ecx+12], edx
	je	SHORT $L17190
	mov	DWORD PTR [edx+24], 0
$L17190:

; 156  :     }
; 157  : 
; 158  :     Type *temp = mFree; // old head of free list.

	mov	edx, DWORD PTR [ecx+16]

; 159  :     mFree = t; // new head of linked list.

	mov	DWORD PTR [ecx+16], eax

; 160  :     t->SetPrevious(0);

	mov	DWORD PTR [eax+24], 0

; 161  :     t->SetNext(temp);

	mov	DWORD PTR [eax+20], edx

; 162  : 
; 163  :     mUsedCount--;

	mov	edx, DWORD PTR [ecx+20]

; 164  :     mFreeCount++;

	mov	eax, DWORD PTR [ecx+24]
	dec	edx
	inc	eax
	mov	DWORD PTR [ecx+20], edx
	mov	DWORD PTR [ecx+24], eax
	pop	esi

; 165  :   };

	pop	ebp
	ret	4
?Release@?$Pool@VSpherePack@@@@QAEXPAVSpherePack@@@Z ENDP ; Pool<SpherePack>::Release
_TEXT	ENDS
;	COMDAT ?GetFreeLink@?$Pool@VSpherePack@@@@QAEPAVSpherePack@@XZ
_TEXT	SEGMENT
?GetFreeLink@?$Pool@VSpherePack@@@@QAEPAVSpherePack@@XZ PROC NEAR ; Pool<SpherePack>::GetFreeLink, COMDAT

; 182  :     // Free allocated items are always added to the head of the list
; 183  :     if ( !mFree ) return 0;

	mov	eax, DWORD PTR [ecx+16]
	test	eax, eax
	jne	SHORT $L13438

; 193  :     return ret;
; 194  :   };

	ret	0
$L13438:

; 184  :     Type *ret = mFree;
; 185  :     mFree = ret->GetNext(); // new head of free list

	mov	edx, DWORD PTR [eax+20]
	mov	DWORD PTR [ecx+16], edx

; 186  :     Type *temp = mHead; // current head of list

	mov	edx, DWORD PTR [ecx+12]

; 187  :     mHead = ret;        // new head of list is this free one
; 188  :     if ( temp ) temp->SetPrevious(ret);

	test	edx, edx
	mov	DWORD PTR [ecx+12], eax
	je	SHORT $L17206
	mov	DWORD PTR [edx+24], eax
$L17206:
	push	esi

; 189  :     mHead->SetNext(temp);

	mov	esi, DWORD PTR [ecx+12]
	mov	DWORD PTR [esi+20], edx

; 190  :     mHead->SetPrevious(0);

	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+24], 0

; 191  :     mUsedCount++;

	mov	esi, DWORD PTR [ecx+20]

; 192  :     mFreeCount--;

	mov	edx, DWORD PTR [ecx+24]
	inc	esi
	dec	edx
	mov	DWORD PTR [ecx+20], esi
	mov	DWORD PTR [ecx+24], edx
	pop	esi

; 193  :     return ret;
; 194  :   };

	ret	0
?GetFreeLink@?$Pool@VSpherePack@@@@QAEPAVSpherePack@@XZ ENDP ; Pool<SpherePack>::GetFreeLink
_TEXT	ENDS
;	COMDAT ??_H@YGXPAXIHP6EX0@Z@Z
_TEXT	SEGMENT
___t$ = 8
___s$ = 12
___n$ = 16
___f$ = 20
??_H@YGXPAXIHP6EX0@Z@Z PROC NEAR			; `vector constructor iterator', COMDAT
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR ___n$[ebp]
	dec	eax
	js	SHORT $L13487
	push	ebx
	mov	ebx, DWORD PTR ___f$[ebp]
	push	esi
	mov	esi, DWORD PTR ___t$[ebp]
	push	edi
	lea	edi, DWORD PTR [eax+1]
$L13486:
	mov	ecx, esi
	call	ebx
	mov	ecx, DWORD PTR ___s$[ebp]
	add	esi, ecx
	dec	edi
	jne	SHORT $L13486
	pop	edi
	pop	esi
	pop	ebx
$L13487:
	pop	ebp
	ret	16					; 00000010H
??_H@YGXPAXIHP6EX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	?id@?$ctype@G@std@@$E				; std::ctype<unsigned short>::id
EXTRN	_atexit:NEAR
_DATA	SEGMENT
COMM	??_B?1???id@?$ctype@G@std@@$D@@9@51:BYTE							; std::ctype<unsigned short>::d::`local static guard'
_DATA	ENDS
_TEXT	SEGMENT
_$E31	PROC NEAR
	mov	cl, BYTE PTR ??_B?1???id@?$ctype@G@std@@$D@@9@51 ; std::ctype<unsigned short>::d::`local static guard'
	mov	al, 1
	test	cl, al
	jne	SHORT $L17225
	or	cl, al
	mov	BYTE PTR ??_B?1???id@?$ctype@G@std@@$D@@9@51, cl ; std::ctype<unsigned short>::d::`local static guard'
$L17225:
	push	OFFSET FLAT:?id@?$ctype@G@std@@$E	; std::ctype<unsigned short>::id
	call	_atexit
	pop	ecx
	ret	0
_$E31	ENDP
_TEXT	ENDS
;	COMDAT ?id@?$ctype@G@std@@$E
_TEXT	SEGMENT
?id@?$ctype@G@std@@$E PROC NEAR				; std::ctype<unsigned short>::id, COMDAT
	ret	0
?id@?$ctype@G@std@@$E ENDP				; std::ctype<unsigned short>::id
_TEXT	ENDS
EXTRN	??0Init@ios_base@std@@QAE@XZ:NEAR		; std::ios_base::Init::Init
_BSS	SEGMENT
__Ios_init DB	01H DUP (?)
_BSS	ENDS
_TEXT	SEGMENT
_$E17	PROC NEAR
	mov	ecx, OFFSET FLAT:__Ios_init
	call	??0Init@ios_base@std@@QAE@XZ		; std::ios_base::Init::Init
	push	OFFSET FLAT:_$E15
	call	_atexit
	pop	ecx
	ret	0
_$E17	ENDP
_TEXT	ENDS
EXTRN	??1Init@ios_base@std@@QAE@XZ:NEAR		; std::ios_base::Init::~Init
_TEXT	SEGMENT
_$E15	PROC NEAR
	mov	ecx, OFFSET FLAT:__Ios_init
	jmp	??1Init@ios_base@std@@QAE@XZ		; std::ios_base::Init::~Init
_$E15	ENDP
_TEXT	ENDS
EXTRN	??0_Winit@std@@QAE@XZ:NEAR			; std::_Winit::_Winit
_BSS	SEGMENT
	ALIGN	4

__Wios_init DB	01H DUP (?)
_BSS	ENDS
_TEXT	SEGMENT
_$E23	PROC NEAR
	mov	ecx, OFFSET FLAT:__Wios_init
	call	??0_Winit@std@@QAE@XZ			; std::_Winit::_Winit
	push	OFFSET FLAT:_$E21
	call	_atexit
	pop	ecx
	ret	0
_$E23	ENDP
_TEXT	ENDS
EXTRN	??1_Winit@std@@QAE@XZ:NEAR			; std::_Winit::~_Winit
_TEXT	SEGMENT
_$E21	PROC NEAR
	mov	ecx, OFFSET FLAT:__Wios_init
	jmp	??1_Winit@std@@QAE@XZ			; std::_Winit::~_Winit
_$E21	ENDP
_TEXT	ENDS
;	COMDAT ??0SpherePack@@QAE@XZ
_TEXT	SEGMENT
??0SpherePack@@QAE@XZ PROC NEAR				; SpherePack::SpherePack, COMDAT

; 80   :   SpherePack(void)

	mov	eax, ecx

; 81   :   {
; 82   :     mUserData         = 0; // default user data is null

	xor	ecx, ecx
	mov	DWORD PTR [eax+64], ecx

; 83   :     mFactory          = 0; // factory we are a member of

	mov	DWORD PTR [eax+68], ecx

; 84   :     mNext             = 0; // linked list pointers

	mov	DWORD PTR [eax+20], ecx

; 85   :     mPrevious         = 0;

	mov	DWORD PTR [eax+24], ecx

; 86   :     mParent           = 0;

	mov	DWORD PTR [eax+28], ecx

; 87   :     mNextSibling      = 0; // our brothers and sisters at this level.

	mov	DWORD PTR [eax+36], ecx

; 88   :     mPrevSibling      = 0;

	mov	DWORD PTR [eax+40], ecx

; 89   :     mChildren         = 0; // our children.

	mov	DWORD PTR [eax+32], ecx

; 90   :     mChildCount       = 0; // number of children we have.

	mov	DWORD PTR [eax+56], ecx

; 91   :     mFifo1            = 0; // our FIFO1 location if we have one.

	mov	DWORD PTR [eax+44], ecx

; 92   :     mFifo2            = 0; // our FIFO2 location if we have one.

	mov	DWORD PTR [eax+48], ecx

; 93   :     SetRadius(0);          // default radius

	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+16], ecx

; 94   :     mCenter.Set(0,0,0);    // default center position.

	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx

; 95   :   };

	ret	0
??0SpherePack@@QAE@XZ ENDP				; SpherePack::SpherePack
_TEXT	ENDS
;	COMDAT ?Init@SpherePack@@QAEXPAVSpherePackFactory@@ABV?$Vector3d@M@@MPAX@Z
_TEXT	SEGMENT
_factory$ = 8
_pos$ = 12
_radius$ = 16
_userdata$ = 20
?Init@SpherePack@@QAEXPAVSpherePackFactory@@ABV?$Vector3d@M@@MPAX@Z PROC NEAR ; SpherePack::Init, COMDAT

; 101  :   {

	push	ebp
	mov	ebp, esp

; 102  :     mUserData         = userdata;

	mov	eax, DWORD PTR _userdata$[ebp]

; 103  :     mParent           = 0;
; 104  :     mNextSibling      = 0;
; 105  :     mPrevSibling      = 0;
; 106  :     mFlags            = 0;
; 107  :     mFifo1            = 0;
; 108  :     mFifo2            = 0;
; 109  :     mFactory          = factory;

	mov	edx, DWORD PTR _factory$[ebp]
	mov	DWORD PTR [ecx+64], eax
	xor	eax, eax

; 110  :     mCenter           = pos;
; 111  :     SetRadius(radius);

	fld	DWORD PTR _radius$[ebp]
	fmul	DWORD PTR _radius$[ebp]
	mov	DWORD PTR [ecx+28], eax
	mov	DWORD PTR [ecx+36], eax
	mov	DWORD PTR [ecx+40], eax
	mov	DWORD PTR [ecx+52], eax
	mov	DWORD PTR [ecx+44], eax
	mov	DWORD PTR [ecx+48], eax
	mov	eax, DWORD PTR _pos$[ebp]
	mov	DWORD PTR [ecx+68], edx
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _radius$[ebp]
	mov	DWORD PTR [ecx+8], eax
	fstp	DWORD PTR [ecx+16]
	mov	DWORD PTR [ecx+12], edx

; 112  :   };

	pop	ebp
	ret	16					; 00000010H
?Init@SpherePack@@QAEXPAVSpherePackFactory@@ABV?$Vector3d@M@@MPAX@Z ENDP ; SpherePack::Init
_TEXT	ENDS
;	COMDAT ?Unlink@SpherePack@@QAEXXZ
_TEXT	SEGMENT
?Unlink@SpherePack@@QAEXXZ PROC NEAR			; SpherePack::Unlink, COMDAT

; 133  :   {

	push	ebx
	mov	ebx, ecx

; 134  :     if ( mFifo1 ) // if we belong to fifo1, null us out

	xor	edx, edx
	push	esi
	mov	eax, DWORD PTR [ebx+44]
	push	edi
	cmp	eax, edx
	je	SHORT $L12395

; 135  :     {
; 136  :       *mFifo1 = 0;

	mov	DWORD PTR [eax], edx

; 137  :       mFifo1 = 0;

	mov	DWORD PTR [ebx+44], edx
$L12395:

; 138  :     }
; 139  : 
; 140  :     if ( mFifo2 ) // if we belong to fifo2, null us out

	mov	eax, DWORD PTR [ebx+48]
	cmp	eax, edx
	je	SHORT $L12396

; 141  :     {
; 142  :       *mFifo2 = 0;

	mov	DWORD PTR [eax], edx

; 143  :       mFifo2 = 0;

	mov	DWORD PTR [ebx+48], edx
$L12396:

; 144  :     }
; 145  : 
; 146  :     if ( mParent ) mParent->LostChild(this);

	mov	esi, DWORD PTR [ebx+28]
	cmp	esi, edx
	je	$L17507
	mov	ecx, DWORD PTR [ebx+40]
	mov	eax, DWORD PTR [ebx+36]
	cmp	ecx, edx
	je	SHORT $L17457
	cmp	eax, edx
	mov	DWORD PTR [ecx+36], eax
	je	SHORT $L17475
	mov	DWORD PTR [eax+40], ecx
	jmp	SHORT $L17475
$L17457:
	cmp	eax, edx
	mov	DWORD PTR [esi+32], eax
	je	SHORT $L17475
	mov	DWORD PTR [eax+40], edx
$L17475:
	mov	eax, DWORD PTR [esi+56]
	dec	eax
	mov	DWORD PTR [esi+56], eax
	jne	SHORT $L17507
	mov	eax, DWORD PTR [esi+52]
	test	al, 1
	je	SHORT $L17507
	mov	edi, DWORD PTR [esi+68]
	test	al, 8
	jne	SHORT $L17507
	test	al, 4
	je	SHORT $L17482
	mov	eax, DWORD PTR [esi+64]
	mov	ecx, edi
	push	eax
	call	?Remove@SpherePackFactory@@QAEXPAVSpherePack@@@Z ; SpherePackFactory::Remove
$L17482:
	mov	ecx, esi
	call	?Unlink@SpherePack@@QAEXXZ		; SpherePack::Unlink
	cmp	esi, DWORD PTR [edi+20]
	jne	SHORT $L17497
	mov	ecx, DWORD PTR [esi+20]
	mov	DWORD PTR [edi+20], ecx
$L17497:
	mov	ecx, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [esi+20]
	xor	edx, edx
	cmp	ecx, edx
	je	SHORT $L17499
	cmp	eax, edx
	mov	DWORD PTR [ecx+20], eax
	je	SHORT $L17449
	mov	DWORD PTR [eax+24], ecx
	jmp	SHORT $L17449
$L17499:
	cmp	eax, edx
	mov	DWORD PTR [edi+28], eax
	je	SHORT $L17449
	mov	DWORD PTR [eax+24], edx
$L17449:
	mov	eax, DWORD PTR [edi+32]
	mov	DWORD PTR [edi+32], esi
	mov	DWORD PTR [esi+24], edx
	mov	DWORD PTR [esi+20], eax
	mov	ecx, DWORD PTR [edi+36]
	mov	eax, DWORD PTR [edi+40]
	dec	ecx
	inc	eax
	mov	DWORD PTR [edi+36], ecx
	mov	DWORD PTR [edi+40], eax
$L17507:
	pop	edi

; 147  : 
; 148  :     assert( !mChildren ); // can't unlink guys with children!
; 149  : 
; 150  :     mParent = 0; // got no father anymore

	mov	DWORD PTR [ebx+28], edx
	pop	esi
	pop	ebx

; 151  :   }

	ret	0
?Unlink@SpherePack@@QAEXXZ ENDP				; SpherePack::Unlink
_TEXT	ENDS
;	COMDAT ?AddChild@SpherePack@@QAEXPAV1@@Z
_TEXT	SEGMENT
_pack$ = 8
?AddChild@SpherePack@@QAEXPAV1@@Z PROC NEAR		; SpherePack::AddChild, COMDAT

; 155  :   {

	push	ebp
	mov	ebp, esp

; 156  : 
; 157  :     SpherePack *my_child = mChildren;

	mov	edx, DWORD PTR [ecx+32]

; 158  :     mChildren = pack; // new head of list

	mov	eax, DWORD PTR _pack$[ebp]
	mov	DWORD PTR [ecx+32], eax

; 159  : 
; 160  :     pack->SetNextSibling(my_child); // his next is my old next
; 161  :     pack->SetPrevSibling(0); // at head of list, no previous
; 162  :     pack->SetParent(this);
; 163  : 
; 164  :     if ( my_child ) my_child->SetPrevSibling(pack); // previous now this..

	test	edx, edx
	mov	DWORD PTR [eax+36], edx
	mov	DWORD PTR [eax+40], 0
	mov	DWORD PTR [eax+28], ecx
	je	SHORT $L17547
	mov	DWORD PTR [edx+40], eax
$L17547:

; 165  : 
; 166  :     mChildCount++;

	inc	DWORD PTR [ecx+56]

; 167  : 
; 168  :     float dist = DistanceSquared(pack);
; 169  :     float radius = sqrtf(dist) + pack->GetRadius();
; 170  : 
; 171  :     assert( radius <= GetRadius() );
; 172  :   }

	pop	ebp
	ret	4
?AddChild@SpherePack@@QAEXPAV1@@Z ENDP			; SpherePack::AddChild
_TEXT	ENDS
;	COMDAT ?ComputeBindingDistance@SpherePack@@QAEXPAV1@@Z
_TEXT	SEGMENT
_parent$ = 8
?ComputeBindingDistance@SpherePack@@QAEXPAV1@@Z PROC NEAR ; SpherePack::ComputeBindingDistance, COMDAT

; 218  :   {

	push	ebp
	mov	ebp, esp

; 219  :     mBindingDistance = parent->GetRadius() - GetRadius();

	mov	eax, DWORD PTR _parent$[ebp]
	fld	DWORD PTR [eax+12]
	fsub	DWORD PTR [ecx+12]

; 220  :     if ( mBindingDistance <= 0 )

	fcom	DWORD PTR __real@4@00000000000000000000
	fst	DWORD PTR [ecx+60]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L12444
	fstp	ST(0)

; 221  :       mBindingDistance = 0;

	mov	DWORD PTR [ecx+60], 0

; 224  :   }

	pop	ebp
	ret	4
$L12444:

; 222  :     else
; 223  :       mBindingDistance*=mBindingDistance;

	fld	ST(0)
	fmul	ST(0), ST(1)
	fstp	DWORD PTR [ecx+60]
	fstp	ST(0)

; 224  :   }

	pop	ebp
	ret	4
?ComputeBindingDistance@SpherePack@@QAEXPAV1@@Z ENDP	; SpherePack::ComputeBindingDistance
_TEXT	ENDS
;	COMDAT ?Push@SpherePackFifo@@QAEPAPAVSpherePack@@PAV2@@Z
_TEXT	SEGMENT
_sphere$ = 8
?Push@SpherePackFifo@@QAEPAPAVSpherePack@@PAV2@@Z PROC NEAR ; SpherePackFifo::Push, COMDAT

; 286  :   {

	push	ebp
	mov	ebp, esp

; 287  :     mCount++;
; 288  :     SpherePack **ret = &mFifo[mSP];

	mov	eax, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR [ecx+16]
	push	esi
	mov	esi, DWORD PTR [ecx]
	inc	esi
	lea	eax, DWORD PTR [edx+eax*4]

; 289  :     mFifo[mSP] = sphere;

	mov	edx, DWORD PTR _sphere$[ebp]
	mov	DWORD PTR [ecx], esi
	mov	DWORD PTR [eax], edx

; 290  :     mSP++;

	mov	edx, DWORD PTR [ecx+4]

; 291  :     if ( mSP == mFifoSize ) mSP = 0;

	mov	esi, DWORD PTR [ecx+12]
	inc	edx
	cmp	edx, esi
	mov	DWORD PTR [ecx+4], edx
	pop	esi
	jne	SHORT $L12483
	mov	DWORD PTR [ecx+4], 0
$L12483:

; 292  :     return ret;
; 293  :   };

	pop	ebp
	ret	4
?Push@SpherePackFifo@@QAEPAPAVSpherePack@@PAV2@@Z ENDP	; SpherePackFifo::Push
_TEXT	ENDS
;	COMDAT ?NewPosRadius@SpherePack@@QAEXABV?$Vector3d@M@@M@Z
_TEXT	SEGMENT
_pos$ = 8
_radius$ = 12
?NewPosRadius@SpherePack@@QAEXABV?$Vector3d@M@@M@Z PROC NEAR ; SpherePack::NewPosRadius, COMDAT

; 443  : {

	push	ebp
	mov	ebp, esp

; 444  :   // New position and, possibly, a new radius.
; 445  : 
; 446  :   mCenter    = pos;

	mov	eax, DWORD PTR _pos$[ebp]
	push	ebx
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [eax]

; 447  : 
; 448  :   if ( mParent && !HasSpherePackFlag(SPF_INTEGRATE) )

	xor	ebx, ebx
	mov	DWORD PTR [esi], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [esi+4], edx
	mov	edx, DWORD PTR [esi+28]
	mov	eax, DWORD PTR [eax+8]
	cmp	edx, ebx
	push	edi
	mov	DWORD PTR [esi+8], eax
	je	$L17745
	test	BYTE PTR [esi+52], 32			; 00000020H
	jne	$L17745

; 449  :   {
; 450  : 
; 451  :     if ( radius != GetRadius() )

	fld	DWORD PTR [esi+12]
	fcomp	DWORD PTR _radius$[ebp]
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L17589

; 452  :     {
; 453  :       SetRadius(radius);

	fld	DWORD PTR _radius$[ebp]
	fmul	DWORD PTR _radius$[ebp]
	mov	ecx, DWORD PTR _radius$[ebp]
	mov	DWORD PTR [esi+12], ecx
	fstp	DWORD PTR [esi+16]

; 454  :       ComputeBindingDistance(mParent);

	fld	DWORD PTR [edx+12]
	fsub	DWORD PTR _radius$[ebp]
	fcom	DWORD PTR __real@4@00000000000000000000
	fst	DWORD PTR [esi+60]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L17588
	fstp	ST(0)
	mov	DWORD PTR [esi+60], ebx
	jmp	SHORT $L17589
$L17588:
	fld	ST(0)
	fmul	ST(0), ST(1)
	fstp	DWORD PTR [esi+60]
	fstp	ST(0)
$L17589:

; 455  :     }
; 456  : 
; 457  :     float dist = DistanceSquared(mParent);

	fld	DWORD PTR [edx]
	fsub	DWORD PTR [esi]
	fld	DWORD PTR [edx+4]
	fsub	DWORD PTR [esi+4]
	fld	DWORD PTR [edx+8]
	fsub	DWORD PTR [esi+8]
	fld	ST(0)
	fmul	ST(0), ST(1)
	fld	ST(2)
	fmul	ST(0), ST(3)

; 464  :     }
; 465  :     else
; 466  :     {
; 467  :       if ( !mParent->HasSpherePackFlag(SPF_RECOMPUTE) ) mFactory->AddRecompute(mParent);

	faddp	ST(1), ST(0)
	fld	ST(3)
	fmul	ST(0), ST(4)
	faddp	ST(1), ST(0)
	fcomp	DWORD PTR [esi+60]
	fstp	ST(0)
	fnstsw	ax
	mov	al, BYTE PTR [edx+52]
	fstp	ST(0)
	test	ah, 1
	fstp	ST(0)
	jne	$L12649

; 458  : 
; 459  :     if ( dist >= mBindingDistance )
; 460  :     {
; 461  :       if ( !mParent->HasSpherePackFlag(SPF_RECOMPUTE) ) mFactory->AddRecompute(mParent);

	test	al, 16					; 00000010H
	jne	SHORT $L17656
	mov	eax, DWORD PTR [edx+52]
	mov	ecx, DWORD PTR [esi+68]
	test	al, 16					; 00000010H
	jne	SHORT $L17656
	cmp	DWORD PTR [edx+56], ebx
	je	SHORT $L17654
	or	al, 16					; 00000010H
	mov	DWORD PTR [edx+52], eax
	mov	eax, DWORD PTR [ecx+48]
	mov	ecx, DWORD PTR [eax]
	mov	edi, DWORD PTR [eax+16]
	inc	ecx
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edi+ecx*4], edx
	lea	ecx, DWORD PTR [edi+ecx*4]
	mov	edi, DWORD PTR [eax+4]
	inc	edi
	cmp	edi, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], edi
	jne	SHORT $L17648
	mov	DWORD PTR [eax+4], ebx
$L17648:
	mov	DWORD PTR [edx+44], ecx
	jmp	SHORT $L17656
$L17654:
	push	edx
	call	?Remove@SpherePackFactory@@QAEXPAVSpherePack@@@Z ; SpherePackFactory::Remove
$L17656:

; 462  :       Unlink();

	mov	eax, DWORD PTR [esi+44]
	cmp	eax, ebx
	je	SHORT $L17661
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [esi+44], ebx
$L17661:
	mov	eax, DWORD PTR [esi+48]
	cmp	eax, ebx
	je	SHORT $L17662
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [esi+48], ebx
$L17662:
	mov	ecx, DWORD PTR [esi+28]
	cmp	ecx, ebx
	je	SHORT $L17663
	push	esi
	call	?LostChild@SpherePack@@QAEXPAV1@@Z	; SpherePack::LostChild
$L17663:

; 463  :       mFactory->AddIntegrate(this);

	mov	al, BYTE PTR [esi+52]
	mov	edi, DWORD PTR [esi+68]
	test	al, 2
	mov	DWORD PTR [esi+28], ebx
	push	esi
	je	SHORT $L17696
	mov	ecx, DWORD PTR [edi+4]
	jmp	SHORT $L17754
$L17696:
	mov	ecx, DWORD PTR [edi+8]
$L17754:
	call	?AddChild@SpherePack@@QAEXPAV1@@Z	; SpherePack::AddChild
	mov	eax, DWORD PTR [esi+52]
	or	al, 32					; 00000020H
	mov	DWORD PTR [esi+52], eax
	mov	eax, DWORD PTR [edi+44]
	mov	edx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+16]
	mov	edi, DWORD PTR [eax]
	inc	edi
	lea	ecx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [ecx], esi
	mov	edx, DWORD PTR [eax+4]
	mov	edi, DWORD PTR [eax+12]
	inc	edx
	cmp	edx, edi
	mov	DWORD PTR [eax+4], edx
	jne	SHORT $L17691
	mov	DWORD PTR [eax+4], ebx
$L17691:
	mov	DWORD PTR [esi+48], ecx
	pop	edi
	pop	esi
	pop	ebx

; 468  :     }
; 469  :   }
; 470  : }

	pop	ebp
	ret	8
$L12649:

; 464  :     }
; 465  :     else
; 466  :     {
; 467  :       if ( !mParent->HasSpherePackFlag(SPF_RECOMPUTE) ) mFactory->AddRecompute(mParent);

	test	al, 16					; 00000010H
	jne	SHORT $L17745
	mov	eax, DWORD PTR [edx+52]
	mov	ecx, DWORD PTR [esi+68]
	test	al, 16					; 00000010H
	jne	SHORT $L17745
	cmp	DWORD PTR [edx+56], ebx
	je	SHORT $L17743
	or	al, 16					; 00000010H
	mov	DWORD PTR [edx+52], eax
	mov	eax, DWORD PTR [ecx+48]
	mov	ecx, DWORD PTR [eax+4]
	mov	esi, DWORD PTR [eax+16]
	mov	edi, DWORD PTR [eax]
	inc	edi
	lea	ecx, DWORD PTR [esi+ecx*4]
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [ecx], edx
	mov	esi, DWORD PTR [eax+4]
	mov	edi, DWORD PTR [eax+12]
	inc	esi
	cmp	esi, edi
	mov	DWORD PTR [eax+4], esi
	jne	SHORT $L17737
	mov	DWORD PTR [eax+4], ebx
$L17737:
	pop	edi
	pop	esi
	mov	DWORD PTR [edx+44], ecx
	pop	ebx

; 468  :     }
; 469  :   }
; 470  : }

	pop	ebp
	ret	8

; 464  :     }
; 465  :     else
; 466  :     {
; 467  :       if ( !mParent->HasSpherePackFlag(SPF_RECOMPUTE) ) mFactory->AddRecompute(mParent);

$L17743:
	push	edx
	call	?Remove@SpherePackFactory@@QAEXPAVSpherePack@@@Z ; SpherePackFactory::Remove
$L17745:
	pop	edi
	pop	esi
	pop	ebx

; 468  :     }
; 469  :   }
; 470  : }

	pop	ebp
	ret	8
?NewPosRadius@SpherePack@@QAEXABV?$Vector3d@M@@M@Z ENDP	; SpherePack::NewPosRadius
_TEXT	ENDS
END
