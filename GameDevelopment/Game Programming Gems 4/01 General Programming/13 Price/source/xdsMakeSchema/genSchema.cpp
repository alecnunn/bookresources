// ----------------------------------------------------------------------------
// 
// This file is part of the XDS Toolkit, Copyright (C) 2003 Mark T. Price
// For conditions of distribution and use, see XdsLicense.h
//
// ----------------------------------------------------------------------------


#include <stdio.h>
#include "XDSinternal.h"
#include "xdsMakeSchema.h"

static const char *GetSchemaTypeName(xdsHandle *hXds, unsigned short iType)
{
	// handle user-defined types
	struct xdsType_t *pType = (struct xdsType_t *)(hXds->pTypeDb->Find((unsigned char *)&iType, sizeof(iType)));
	if(pType)
	{
		return pType->szName;
	}

	// handle built-in types
	switch(iType)
	{
	case XDS_TYPE_CHAR:     return "xs:byte";
	case XDS_TYPE_BYTE:		return "xs:unsignedByte";
	case XDS_TYPE_SHORT:    return "xs:short";
	case XDS_TYPE_WORD:		return "xs:unsignedShort";
	case XDS_TYPE_LONG:		return "xs:long";
	case XDS_TYPE_DWORD:	return "xs:unsignedLong";
	case XDS_TYPE_BCSTRING:	return "xs:string";
	case XDS_TYPE_WCSTRING:	return "xs:string";
	case XDS_TYPE_FLOAT:	return "xs:float";
	case XDS_TYPE_DOUBLE:	return "xs:float";
	}

	// unknown type!
	fprintf(stderr, "Unknown/Invalid type ID '0x%04x' -- aborting\n", iType);
	exit(1);
}

void writeXMLSchema(FILE *fp, xdsHandle *hXds)
{
	CTrieIterator it(*hXds->pTypeDb);

	// write XMl Schema Definition intro
	fputs("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n", fp);
	fputs("<!-- This file was generated by the XDS toolkit utility 'xdsMakeSchema'\n", fp);
	fputs("     For more information about the XDS toolkit see the XDS Resources\n", fp);
	fputs("     web page at \"http://www.suddenpresence.com/xds\" -->\n", fp);
	fputs("<xs:schema xmlns:xs=\"http://www.w3.org/2001/XMLSchema\" elementFormDefault=\"unqualified\" attributeFormDefault=\"unqualified\">\n", fp);

	// We output all type definitions first.
	// At the same time, we keep track if any record definitions exist since we
	// have to output the default record type if they don't.

	int iRecordCount = 0;
	int iGlobalElementCount = 0;

	for(; !it.AtEnd(); ++it)
	{
		void *data = it.GetData();
		if(*(u16*)data == XDS_RECORD_RECORDDEF)
		{
			++iRecordCount;
		}
		else if(*(u16*)data == XDS_RECORD_ELEMDEF)
		{
			if(((struct xdsElement_t*)data)->iRecord == 0)
				++iGlobalElementCount;
		}
		else if(*(u16*)data == XDS_RECORD_TYPEDEF)
		{
			struct xdsType_t *pType = (struct xdsType_t*)data;
			switch(pType->iType)
			{
			case XDS_META_TYPE_INTEGER:
				fprintf(fp, "\t<xs:simpleType name=\"%s\" final=\"#all\">\n"
					"\t\t<xs:restriction base=\"xs:%s\"/>\n"
					"\t</xs:simpleType>\n",
					pType->szName, pType->var.int_t.bSigned ? "integer" : "unsignedInt");
				break;

			case XDS_META_TYPE_ENUMERATION:
				{
					fprintf(fp, "\t<xs:simpleType name=\"%s\" final=\"#all\">\n"
						"\t\t<xs:restriction base=\"xs:string\">\n",
						pType->szName);

					struct xdsEnum_t *pEnum = pType->var.enum_t.pEnums;
					for(int ii = 0; ii < pType->var.enum_t.iEnumCount; ++ii, ++pEnum)
					{
						fprintf(fp, "\t\t\t<xs:enumeration value=\"%s\"/>\n", pEnum->szName);
					}
					fprintf(fp, "\t\t</xs:restriction>\n"
						"\t</xs:simpleType>\n");
					break;
				}

			case XDS_META_TYPE_STRING:
					fprintf(fp, "\t<xs:simpleType name=\"%s\" final=\"#all\">\n"
					"\t\t<xs:restriction base=\"xs:string\">\n", pType->szName);
				if(pType->var.string_t.iLengthSize < 0) // fixed size string?
					fprintf(fp, "\t\t\t<xs:maxLength value=\"%d\"/>\n", pType->var.string_t.iLength);
				fprintf(fp, "\t\t</xs:restriction>\n"
					"\t</xs:simpleType>\n");
				break;

			case XDS_META_TYPE_FIXEDPOINT:
				fprintf(fp, "\t<xs:simpleType name=\"%s\" final=\"#all\">\n"
					"\t\t<xs:restriction base=\"xs:decimal\"/>\n"
					"\t</xs:simpleType>\n",
					pType->szName);
				break;

			case XDS_META_TYPE_FLOATINGPOINT:
				fprintf(fp, "\t<xs:simpleType name=\"%s\" final=\"#all\">\n"
					"\t\t<xs:restriction base=\"xs:double\"/>\n"
					"\t</xs:simpleType>\n",
					pType->szName);
				break;

			case XDS_META_TYPE_BITFIELD:
				fprintf(fp, "\t<xs:simpleType name=\"%s\" final=\"#all\">\n"
					"\t\t<xs:restriction base=\"xs:string\">\n"
					"\t\t\t<xs:length value=\"%d\"/>\n"
					"\t\t\t<xs:pattern value=\"(0|1)*\"/>\n"
					"\t\t</xs:restriction>\n"
					"\t</xs:simpleType>\n",
					pType->szName, pType->var.bitfield_t.iBitCount);
				break;

			case XDS_META_TYPE_ARRAY:
				// special case for character arrays
				if(pType->var.array_t.iBaseType == XDS_TYPE_CHAR)
				{
					if(pType->var.array_t.iDefaultSize)
					{
						// fixed length
						fprintf(fp, "\t\t<xs:simpleType name=\"%s\" final=\"#all\">\n"
							"\t\t\t<xs:restriction base=\"xs:string\">\n"
							"\t\t\t\t<xs:maxLength value=\"%d\"/>\n"
							"\t\t\t</xs:restriction>\n"
							"\t\t</xs:simpleType>\n", 
							pType->szName, pType->var.array_t.iDefaultSize);
					}
					else
					{
						fprintf(fp, "\t<xs:simpleType name=\"%s\" final=\"#all\">\n"
							"\t\t<xs:restriction base=\"xs:string\">\n"
							"\t\t</xs:restriction>\n"
							"\t</xs:simpleType>\n", pType->szName);
					}
				}
				else
				{
					fprintf(fp, "\t<xs:complexType name=\"%s\" final=\"#all\">\n", pType->szName);
					if(pType->var.array_t.iDefaultSize)
					{
						fprintf(fp, "\t\t<xs:sequence minOccurs=\"%d\" maxOccurs=\"%d\">\n",
							pType->var.array_t.iDefaultSize, pType->var.array_t.iDefaultSize);
					}
					else
						fprintf(fp, "\t\t<xs:sequence minOccurs=\"0\" maxOccurs=\"unbounded\">\n");
					fprintf(fp, "\t\t\t<xs:element name=\"entry\" type=\"%s\"/>\n"
						"\t\t</xs:sequence>\n"
//						"\t\t<xs:attribute name=\"count\" type=\"xs:nonNegativeInteger\" use=\"optional\"/>\n"
						"\t</xs:complexType>\n",
						GetSchemaTypeName(hXds, pType->var.array_t.iBaseType));
				}
				break;

			case XDS_META_TYPE_STRUCTURE:
				{
					fprintf(fp, "\t<xs:complexType name=\"%s\" final=\"#all\">\n"
						"\t\t<xs:sequence>\n",
						pType->szName);

					xdsField_t *pField = pType->var.struct_t.pFields;
					for(int ii = 0; ii < pType->var.struct_t.iFieldCount; ++ii, ++pField)
					{
						if(pField->iArraySize > 1)
						{
							// special case for character arrays
							if(pField->iType == XDS_TYPE_CHAR)
							{
								fprintf(fp, "\t\t\t<xs:element name=\"%s\">\n"
									"\t\t\t\t<xs:simpleType>\n"
									"\t\t\t\t\t<xs:restriction base=\"xs:string\">\n"
									"\t\t\t\t\t\t<xs:maxLength value=\"%d\"/>\n"
									"\t\t\t\t\t</xs:restriction>\n"
									"\t\t\t\t</xs:simpleType>\n" 
									"\t\t\t</xs:element>\n",
									pField->szName, pField->iArraySize);
							}
							else
							{
								fprintf(fp, "\t\t\t<xs:element name=\"%s\">\n"
									"\t\t\t\t<xs:complexType>\n"
									"\t\t\t\t\t<xs:sequence minOccurs=\"%d\" maxOccurs=\"%d\">\n"
									"\t\t\t\t\t\t<xs:element name=\"entry\" type=\"%s\"/>\n"
									"\t\t\t\t\t</xs:sequence>\n"
									"\t\t\t\t</xs:complexType>\n"
									"\t\t\t</xs:element>\n",
									pField->szName, pField->iArraySize, pField->iArraySize,
									GetSchemaTypeName(hXds, pField->iType));
							}
						}
						else
						{
							fprintf(fp, "\t\t\t<xs:element name=\"%s\" type=\"%s\"/>\n",
								pField->szName, GetSchemaTypeName(hXds, pField->iType));
						}
					}
					fprintf(fp, "\t\t</xs:sequence>\n"
						"\t</xs:complexType>\n");
					break;
				}

			case XDS_META_TYPE_GRAPH:
				fprintf(stderr, "XDS Graph types are not supported in XML schema");
				exit(1);

			case XDS_META_TYPE_POINTER:
				fprintf(fp, "\t<xs:simpleType name=\"%s\" final=\"#all\">\n"
					"\t\t<xs:restriction base=\"xs:unsignedLong\"/>\n"
					"\t</xs:simpleType>\n",
					pType->szName);
				break;

			default:
				fprintf(stderr, "unknown type: 0x%x\n", pType->iType);
				exit(1);
				break;
			}
		}
	}


	// write document name element
	fprintf(fp, "\t<xs:element name=\"%s\">\n", makeStreamName(hXds));

	fprintf(fp, "\t\t<xs:complexType>\n");

	// write record elements
	if(iRecordCount == 0)
	{
		// write default record element
		fprintf(fp, "\t\t\t<xs:sequence minOccurs=\"0\" maxOccurs=\"unbounded\">\n"
			"\t\t\t\t<xs:element name=\"xdsDataRecord\">\n");
		if(iGlobalElementCount > 0)
			fprintf(fp,
				"\t\t\t\t\t<xs:complexType>\n"
				"\t\t\t\t\t\t<xs:sequence minOccurs=\"0\" maxOccurs=\"unbounded\">\n"
				"\t\t\t\t\t\t\t<xs:group ref=\"_xdsGlobalElements\"/>\n"
				"\t\t\t\t\t\t</xs:sequence>\n"
				"\t\t\t\t\t</xs:complexType>\n");
		fprintf(fp, 
			"\t\t\t\t</xs:element>\n"
			"\t\t\t</xs:sequence>\n");
	}
	else
	{
		if(iRecordCount == 1)
			fprintf(fp, "\t\t\t<xs:sequence minOccurs=\"0\" maxOccurs=\"unbounded\">\n");
		else // if(iRecordCount > 1)
			fprintf(fp, "\t\t\t<xs:choice minOccurs=\"0\" maxOccurs=\"unbounded\">\n");

		// write declared record elements
		for(it.Rewind(); !it.AtEnd(); ++it)
		{
			void *data = it.GetData();
			if(*(u16*)data == XDS_RECORD_RECORDDEF)
			{
				struct xdsRecord_t *pRec = (struct xdsRecord_t*)data;

				fprintf(fp, "\t\t\t\t<xs:element name=\"%s\">\n"
					"\t\t\t\t\t<xs:complexType>\n",
					pRec->szName);

				// search for & write dependent elements / attributes
				int iAttributeCount = 0;
				int iElementCount   = 0;

				CTrieIterator it2(*hXds->pTypeDb);
				for(; !it2.AtEnd(); ++it2)
				{
					void *data = it2.GetData();
					if(*(u16*)data == XDS_RECORD_ATTRIBDEF)
					{
						struct xdsElement_t *pAttrib = (struct xdsElement_t*)data;
						if(pAttrib->iRecord == pRec->iRecordId)
						{
							++iAttributeCount;
						}
					}
					else if(*(u16*)data == XDS_RECORD_ELEMDEF)
					{
						struct xdsElement_t *pElem = (struct xdsElement_t*)data;
						if(pElem->iRecord == pRec->iRecordId)
						{
							if(iElementCount == 0)
								fprintf(fp, "\t\t\t\t\t\t<xs:choice minOccurs=\"0\" maxOccurs=\"unbounded\">\n");

							fprintf(fp, "\t\t\t\t\t\t\t<xs:element name=\"%s\" type=\"%s\"/>\n",
								pElem->szName, GetSchemaTypeName(hXds, pElem->iType));

							++iElementCount;
						}
					}
				}

				if(iElementCount > 0)
				{
					if(iGlobalElementCount > 0)
						fprintf(fp, "\t\t\t\t\t\t\t<xs:group ref=\"_xdsGlobalElements\"/>\n");
					fprintf(fp, "\t\t\t\t\t\t</xs:choice>\n");
				}
				else if(iGlobalElementCount > 0)
				{
					fprintf(fp, "\t\t\t\t\t\t<xs:sequence minOccurs=\"0\" maxOccurs=\"unbounded\">\n"
					            "\t\t\t\t\t\t\t<xs:group ref=\"_xdsGlobalElements\"/>\n"
					            "\t\t\t\t\t\t</xs:sequence>\n");
				}

				if(iAttributeCount > 0)
				{
					for(it2.Rewind(); !it2.AtEnd(); ++it2)
					{
						void *data = it2.GetData();
						if(*(u16*)data == XDS_RECORD_ATTRIBDEF)
						{
							struct xdsElement_t *pAttrib = (struct xdsElement_t*)data;
							if(pAttrib->iRecord == pRec->iRecordId)
							{
								fprintf(fp, "\t\t\t\t\t\t<xs:attribute name=\"%s\" type=\"%s\" use=\"optional\"/>\n",
									pAttrib->szName, GetSchemaTypeName(hXds, pAttrib->iType));
							}
						}
					}
				}

				// end record
				fprintf(fp,	"\t\t\t\t\t</xs:complexType>\n"
					"\t\t\t\t</xs:element>\n");
			}
		}
		if(iRecordCount == 1)
			fprintf(fp, "\t\t\t</xs:sequence>\n");
		else // if(iRecordCount > 1)
			fprintf(fp, "\t\t\t</xs:choice>\n");
	}


	// end document name element
	fprintf(fp, "\t\t</xs:complexType>\n"
		"\t</xs:element>\n");

	if(iGlobalElementCount > 0)
		// write remaining schema nodes
		fprintf(fp, "\t<xs:group name=\"_xdsGlobalElements\">\n"
			"\t\t<xs:choice>\n");

	for(it.Rewind(); !it.AtEnd(); ++it)
	{
		void *data = it.GetData();
		switch(*(u16*)data)
		{
//		case XDS_RECORD_ENCODING:
//			{
//				// multiple encodings are not supported in XML, just write it as a comment
//				struct xdsEncoding_t *pEnc = (struct xdsEncoding_t*)data;
//				fprintf(fp, "\t\t\t<!-- Encoding '%s' -->\n", pEnc->szName);
//				break;
//			}
		case XDS_RECORD_RECORDDEF:
			{
				// already output all type info
				break;
			}
		case XDS_RECORD_ELEMDEF:
			{
				// only write unconstrained elements, constrained elements are written inside their parent records
				struct xdsElement_t *pElem = (struct xdsElement_t*)data;
				if(pElem->iRecord == 0)
					fprintf(fp, "\t\t\t<xs:element name=\"%s\" type=\"%s\"/>\n", pElem->szName, GetSchemaTypeName(hXds, pElem->iType));
				break;
			}
		case XDS_RECORD_ATTRIBDEF:
			{
				// all attributes are constrained (output inside of records)
				break;
			}
		case XDS_RECORD_TYPEDEF:
			{
				// already output all type info
				break;
			}
		default:
			fprintf(stderr, "unknown node type: 0x%x\n", *(u16*)data);
			exit(1);
			break;
		}
	}

	// terminate schema
	if(iGlobalElementCount > 0)
		fprintf(fp, "\t\t</xs:choice>\n"
			"\t</xs:group>\n");
	fprintf(fp, "</xs:schema>\n");
}
